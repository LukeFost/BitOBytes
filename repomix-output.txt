This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-26T21:35:27.800Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  bitobytes_backend/
    main.mo
  bitobytes_frontend/
    src/
      components/
        login/
          ConnectButton.module.css
          ConnectButton.tsx
          LoginButton.tsx
          LoginPage.tsx
        Navigation.tsx
        VideoPlayer.tsx
        VideoUploadForm.tsx
      context/
        AuthContext.tsx
        AuthProvider.tsx
        index.tsx
      pages/
        api/
          v2/
            canister/
              [canisterId]/
                call.ts
                read_state.ts
            status.ts
          v3/
            canister/
              [canisterId]/
                call.ts
        video/
          [id].tsx
        _app.tsx
        allProfiles.tsx
        index.tsx
        profile.tsx
        signin.tsx
        upload.tsx
      styles/
        globals.css
      types/
        next.d.ts
      utils/
        agent.ts
        canisterUtils.ts
        ipfs.ts
        rootKeyFetch.ts
      wagmi/
        is-chain-id-supported.tsx
        wagmi.config.ts
      AuthGuard.tsx
      index.html
    .gitignore
    next.config.js
    package.json
    postcss.config.cjs
    tailwind.config.cjs
    tsconfig.json
  helia_node/
    temp/
      06214f4d-1886-4c46-8a4f-b27361272068/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
      07fc3ec0-903d-4954-951c-32f19610f4b2/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
      2ca0deb0-8a86-4e38-b09f-4ca6a4d172f3/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
      39a3f9fc-6cdb-435a-a0bb-77f7dc3a4880/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
      4de293dc-a144-4067-82df-2fa09b3a9433/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
      5fba6c54-e78e-4d2e-8788-f22cd2fa19de/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
      951a93a4-dd3c-4ef5-9f2d-0c20e8571911/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
      b065030a-8d29-4b9c-9b2b-9da60c9be8f9/
        360p/
          playlist.m3u8
        480p/
          playlist.m3u8
        720p/
          playlist.m3u8
        master.m3u8
    .gitignore
    package.json
    server.js
  ic_siwe_provider/
    declarations/
      index.js
    main.mo
.gitattributes
.gitignore
.ic-assets.json5
clean.sh
deploy-rust-siwe.sh
deploy-siwe.sh
deploy.sh
dfx.json
FIX-SIWE-STEPS.md
LICENSE
make-scripts-executable.sh
README-SIWE.md
README.md
reset-siwe.sh
setup.sh
SIWE-BLS-FIX.md
SIWE-IMPLEMENTATION.md
SIWE-MIGRATION.md
SIWE-TROUBLESHOOTING.md
test-siwe-canister.sh
update-dependencies.sh
verify-siwe-setup.sh

================================================================
Files
================================================================

================
File: src/bitobytes_backend/main.mo
================
import Time "mo:base/Time";
import Nat "mo:base/Nat";
import Nat64 "mo:base/Nat64";
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Hash "mo:base/Hash";
import Array "mo:base/Array";

actor {
  /*************************************************
   * Video Types & Logic (already present)
   *************************************************/
  public type Video = {
    id: Nat64;
    uploader: Principal;
    title: Text;
    mediaRef: Text;
    thumbnailCid: Text;
    hlsCid: Text;
    duration: Nat;
    likes: Nat;
    views: Nat; // Add view count field
    timestamp: Int;
  };

  // Storage for videos
  private stable var nextId: Nat64 = 0;
  private var videos = HashMap.HashMap<Nat64, Video>(0, Nat64.equal, func(n: Nat64) : Hash.Hash { Hash.hash(Nat64.toNat(n)) });

  // Method to add a new video
  public shared(msg) func addVideo(title: Text, mediaRef: Text, thumbnailCid: Text, hlsCid: Text, duration: Nat) : async Nat64 {
    let videoId = nextId;
    let video: Video = {
      id = videoId;
      uploader = msg.caller;
      title = title;
      mediaRef = mediaRef;
      thumbnailCid = thumbnailCid;
      hlsCid = hlsCid;
      duration = duration;
      likes = 0;
      views = 0; // Initialize views to 0
      timestamp = Time.now();
    };
    
    videos.put(videoId, video);
    nextId += 1;
    
    return videoId;
  };

  // Method to get all videos
  public query func getVideos() : async [Video] {
    return Iter.toArray(videos.vals());
  };

  // Method to like a video
  public func likeVideo(videoId: Nat64) : async Bool {
    switch (videos.get(videoId)) {
      case (null) {
        return false; // Video not found
      };
      case (?video) {
        let updatedVideo: Video = {
          id = video.id;
          uploader = video.uploader;
          title = video.title;
          mediaRef = video.mediaRef;
          thumbnailCid = video.thumbnailCid;
          hlsCid = video.hlsCid;
          duration = video.duration;
          likes = video.likes + 1;
          views = video.views;
          timestamp = video.timestamp;
        };
        videos.put(videoId, updatedVideo);
        return true;
      };
    }
  };

  // Method to get a single video by ID
  public query func getVideo(videoId: Nat64) : async ?Video {
    return videos.get(videoId);
  };

  // Method to increment view count
  public func incrementViewCount(videoId: Nat64) : async Bool {
    switch (videos.get(videoId)) {
      case (null) {
        return false; // Video not found
      };
      case (?video) {
        let updatedVideo: Video = {
          id = video.id;
          uploader = video.uploader;
          title = video.title;
          mediaRef = video.mediaRef;
          thumbnailCid = video.thumbnailCid;
          hlsCid = video.hlsCid;
          duration = video.duration;
          likes = video.likes;
          views = video.views + 1; // Increment view count
          timestamp = video.timestamp;
        };
        videos.put(videoId, updatedVideo);
        return true;
      };
    }
  };

  /*************************************************
   * NEW: Profile Types & Logic
   *************************************************/
  public type UserProfile = {
    name: Text;
    avatarUrl: Text;
    owner: Principal;
  };

  // Store profiles by Principal
  private var profiles = HashMap.HashMap<Principal, UserProfile>(
    0,
    Principal.equal,
    Principal.hash
  );

  /**
   * Set (or update) the caller's profile
   */
  public shared(msg) func saveMyProfile(name: Text, avatarUrl: Text) : async UserProfile {
    let callerPrincipal = msg.caller;
    let profile: UserProfile = {
      name = name;
      avatarUrl = avatarUrl;
      owner = callerPrincipal;
    };
    profiles.put(callerPrincipal, profile);
    return profile;
  };

  /**
   * Get the caller's own profile
   */
  public shared query(msg) func getMyProfile() : async ?UserProfile {
    return profiles.get(msg.caller);
  };

  /**
   * A method to list all profiles
   */
  public query func listProfiles() : async [UserProfile] {
    return Iter.toArray(profiles.vals());
  };

  /**
   * Get only the videos that belong to the caller
   */
  public shared query(msg) func getMyVideos() : async [Video] {
    let callerPrincipal = msg.caller;
    let allVideos = Iter.toArray(videos.vals());
    
    return Array.filter<Video>(allVideos, func (v: Video) : Bool {
      Principal.equal(v.uploader, callerPrincipal)
    });
  };
}

================
File: src/bitobytes_frontend/src/components/login/ConnectButton.module.css
================
.connect-button-container {
  margin-bottom: 1rem;
}

.connect-button {
  background-color: #3b82f6;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.connect-button:hover {
  background-color: #2563eb;
}

.connect-button:disabled {
  background-color: #93c5fd;
  cursor: not-allowed;
}

.wallet-info {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.address-display {
  font-family: monospace;
  padding: 0.25rem 0.5rem;
  background-color: #f3f4f6;
  border-radius: 0.25rem;
  display: inline-block;
}

.disconnect-button {
  background-color: #ef4444;
  color: white;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.875rem;
  cursor: pointer;
  transition: background-color 0.2s;
  width: fit-content;
}

.disconnect-button:hover {
  background-color: #dc2626;
}

.unsupported-chain-warning {
  color: #ef4444;
  font-size: 0.875rem;
  margin-bottom: 0.5rem;
}

.connect-error {
  color: #ef4444;
  font-size: 0.875rem;
  margin-top: 0.5rem;
}

================
File: src/bitobytes_frontend/src/components/login/ConnectButton.tsx
================
import React, { useState, useEffect } from 'react';
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { isChainIdSupported } from '../../wagmi/is-chain-id-supported';

const ConnectButton: React.FC = () => {
  const [isConnecting, setIsConnecting] = useState(false);
  const { address, chainId, isConnected } = useAccount();
  const { connect, connectors, error, isPending: isLoading } = useConnect();
  const { disconnect } = useDisconnect();

  // Log available connectors on component mount
  useEffect(() => {
    console.log('Available connectors:', connectors.map(c => ({ name: c.name, ready: c.ready })));
  }, [connectors]);

  const handleConnect = async () => {
    setIsConnecting(true);
    try {
      // Specifically look for the injected connector (MetaMask)
      const injectedConnector = connectors.find(c => c.name === 'Injected');
      
      if (injectedConnector) {
        console.log('Connecting with MetaMask...');
        await connect({ connector: injectedConnector });
      } else {
        console.error('MetaMask connector not found');
        // Try any available connector as fallback
        const anyConnector = connectors.find(c => c.ready);
        if (anyConnector) {
          console.log('Connecting with fallback connector:', anyConnector.name);
          await connect({ connector: anyConnector });
        } else {
          console.error('No ready connectors found');
        }
      }
    } catch (err) {
      console.error('Connection error:', err);
    } finally {
      setIsConnecting(false);
    }
  };

  const handleDisconnect = () => {
    disconnect();
  };

  // Check if the connected chain is supported
  const isUnsupportedChain = chainId ? !isChainIdSupported(chainId) : false;

  return (
    <div className="w-full">
      {!isConnected ? (
        <button
          onClick={handleConnect}
          disabled={isLoading || isConnecting}
          className="w-full py-3 px-4 bg-white border-2 border-gray-800 hover:bg-gray-100 text-gray-900 font-medium rounded-md text-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading || isConnecting ? 'Connecting...' : 'Connect Wallet'}
        </button>
      ) : (
        <div className="w-full">
          {isUnsupportedChain ? (
            <div className="text-red-600 text-sm font-medium mb-2">
              Unsupported network. Please switch to a supported network.
            </div>
          ) : (
            <div className="font-mono bg-gray-100 p-2 rounded-md text-center mb-2">
              {address?.slice(0, 6)}...{address?.slice(-4)}
            </div>
          )}
          <button 
            onClick={handleDisconnect} 
            className="w-full py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-medium rounded-md text-center transition-colors"
          >
            Disconnect
          </button>
        </div>
      )}
      {error && (
        <div className="mt-2 text-red-600 text-sm">
          {error.message}
        </div>
      )}
    </div>
  );
};

export default ConnectButton;

================
File: src/bitobytes_frontend/src/components/login/LoginButton.tsx
================
import React, { useEffect } from 'react';
import { useAccount, useChainId } from 'wagmi';
import { useSiwe } from 'ic-siwe-js/react';
import { isChainIdSupported } from '../../wagmi/is-chain-id-supported';

const LoginButton: React.FC = () => {
  const { isConnected } = useAccount();
  const chainId = useChainId();
  const { 
    login, 
    isLoggingIn, 
    isPreparingLogin, 
    loginError,
    prepareLoginStatus,
    loginStatus,
    identity,
    delegationChain
  } = useSiwe();

  // Log errors for debugging
  useEffect(() => {
    if (loginError) {
      console.error('Login error:', loginError);
      console.error('Login error stack:', loginError.stack);
    }
  }, [loginError]);

  // Log SIWE state for debugging
  useEffect(() => {
    console.log('SIWE State:', { 
      isConnected, 
      chainId,
      isLoggingIn,
      isPreparingLogin,
      prepareLoginStatus,
      loginStatus,
      hasIdentity: !!identity,
      hasDelegationChain: !!delegationChain
    });
  }, [isConnected, chainId, isLoggingIn, isPreparingLogin, prepareLoginStatus, loginStatus, identity, delegationChain]);

  // Enhanced login function with more logging
  const handleLogin = async () => {
    try {
      console.log('Starting login process...');
      console.log('Current chain ID:', chainId);
      console.log('Is chain supported:', isChainIdSupported(chainId));
      console.log('Is connected:', isConnected);
      console.log('Prepare login status:', prepareLoginStatus);
      console.log('Login status:', loginStatus);
      
      // Call the login function
      console.log('Calling login function...');
      await login();
      console.log('Login function completed');
    } catch (error) {
      console.error('Login function threw an error:', error);
      if (error instanceof Error) {
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
      }
    }
  };

  // Button text based on state
  const text = () => {
    if (isLoggingIn) {
      return "Signing in";
    }
    if (isPreparingLogin) {
      return "Preparing";
    }
    return "Sign Wallet";
  };

  // Determine button state
  const disabled =
    !isChainIdSupported(chainId) ||
    isLoggingIn ||
    !isConnected ||
    isPreparingLogin;

  return (
    <div className="w-full">
      <button
        onClick={handleLogin}
        disabled={disabled}
        className="w-full py-3 px-4 bg-white border-2 border-gray-800 hover:bg-gray-100 text-gray-900 font-medium rounded-md text-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {text()}
      </button>

      {loginError && (
        <div className="mt-2 text-red-600 text-sm">
          Error: {loginError.message}
        </div>
      )}

      {!isChainIdSupported(chainId) && (
        <div className="mt-2 text-yellow-600 text-sm">
          Please switch to a supported network to sign in.
        </div>
      )}
    </div>
  );
};

export default LoginButton;

================
File: src/bitobytes_frontend/src/components/login/LoginPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useAccount, useSignMessage } from 'wagmi';
import ConnectButton from './ConnectButton';
import LoginButton from './LoginButton';

const LoginPage: React.FC = () => {
  const { isConnected, address } = useAccount();
  const { signMessageAsync, isPending, error } = useSignMessage();
  const [testSignResult, setTestSignResult] = useState<string | null>(null);
  const [testSignError, setTestSignError] = useState<string | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<string>('');

  // Update connection status when isConnected changes
  useEffect(() => {
    if (isConnected) {
      setConnectionStatus('Connected to wallet');
    } else {
      setConnectionStatus('');
    }
  }, [isConnected]);

  // Function to test signing a message
  const handleTestSign = async () => {
    if (!isConnected || !address) {
      setTestSignError('Please connect your wallet first');
      return;
    }

    setTestSignResult(null);
    setTestSignError(null);

    try {
      // Create a test message with timestamp to make it unique
      const message = `Test signing with address ${address} at ${new Date().toISOString()}`;
      
      // Sign the message
      const signature = await signMessageAsync({ message });
      
      // Display the result
      setTestSignResult(`Message signed successfully! Signature: ${signature.slice(0, 20)}...`);
    } catch (err) {
      console.error('Test sign error:', err);
      setTestSignError(`Failed to sign message: ${err instanceof Error ? err.message : String(err)}`);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-[70vh] p-4">
      <h1 className="text-3xl font-bold mb-10 text-center">Sign in with Ethereum</h1>
      
      {connectionStatus && (
        <div className="mb-6 text-green-600 font-medium">
          {connectionStatus}
        </div>
      )}
      
      <div className="w-full max-w-md flex flex-col items-center space-y-6">
        {/* Connect Wallet Button - Always visible */}
        <div className="w-full max-w-xs">
          <ConnectButton />
        </div>

        {/* Sign In Button - Always visible but may be disabled */}
        <div className="w-full max-w-xs">
          <LoginButton />
        </div>

        {/* Test Sign Button - Always visible but may be disabled */}
        <div className="w-full max-w-xs">
          <button
            onClick={handleTestSign}
            disabled={!isConnected || isPending}
            className="w-full py-3 px-4 bg-white border-2 border-gray-800 hover:bg-gray-100 text-gray-900 font-medium rounded-md text-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isPending ? 'Signing...' : 'Test Sign'}
          </button>
        </div>
        
        {/* Results and Errors */}
        {testSignResult && (
          <div className="mt-4 p-3 bg-green-100 text-green-800 rounded-md w-full max-w-xs">
            {testSignResult}
          </div>
        )}
        
        {(testSignError || error) && (
          <div className="mt-4 p-3 bg-red-100 text-red-800 rounded-md w-full max-w-xs">
            {testSignError || error?.message}
          </div>
        )}
      </div>
    </div>
  );
};

export default LoginPage;

================
File: src/bitobytes_frontend/src/components/Navigation.tsx
================
import React from 'react';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { useAuth } from '../context/AuthContext';

const Navigation: React.FC = () => {
  const router = useRouter();
  const { isAuthenticated, logout } = useAuth();

  // Check if the current route matches the given path
  const isActive = (path: string) => router.pathname === path;

  return (
    <nav className="bg-gray-800 text-white p-4">
      <div className="container mx-auto flex justify-between items-center">
        <div className="flex items-center">
          <Link href="/" className="text-xl font-bold">
            BitOBytes
          </Link>
          
          <div className="ml-8 flex space-x-4">
            <Link 
              href="/" 
              className={`hover:text-blue-300 ${isActive('/') ? 'text-blue-300' : ''}`}
            >
              Home
            </Link>
            
            {isAuthenticated && (
              <>
                <Link 
                  href="/profile" 
                  className={`hover:text-blue-300 ${isActive('/profile') ? 'text-blue-300' : ''}`}
                >
                  Profile
                </Link>
                <Link 
                  href="/allProfiles" 
                  className={`hover:text-blue-300 ${isActive('/allProfiles') ? 'text-blue-300' : ''}`}
                >
                  All Profiles
                </Link>
                <Link 
                  href="/upload" 
                  className={`hover:text-blue-300 ${isActive('/upload') ? 'text-blue-300' : ''}`}
                >
                  Upload Video
                </Link>
              </>
            )}
          </div>
        </div>
        
        <div>
          {isAuthenticated ? (
            <button 
              onClick={() => {
                logout();
                router.push('/');
              }}
              className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded"
            >
              Sign Out
            </button>
          ) : (
            <Link 
              href="/signin" 
              className={`bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded ${isActive('/signin') ? 'bg-blue-700' : ''}`}
            >
              Sign In
            </Link>
          )}
        </div>
      </div>
    </nav>
  );
};

export default Navigation;

================
File: src/bitobytes_frontend/src/components/VideoPlayer.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import { getHlsUrl, getIpfsUrl } from '../utils/ipfs';
import { likeVideo } from '../utils/canisterUtils';

interface VideoPlayerProps {
  videoId: bigint;
  title: string;
  mediaRef: string;
  thumbnailCid: string;
  hlsCid: string;
  duration: number;
  likes: number;
  views: number;
  onLike?: () => void;
}

const VideoPlayer: React.FC<VideoPlayerProps> = ({
  videoId,
  title,
  mediaRef,
  thumbnailCid,
  hlsCid,
  duration,
  likes,
  views,
  onLike
}) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [likeCount, setLikeCount] = useState(isNaN(likes) ? 0 : likes);
  const [isLiked, setIsLiked] = useState(false);
  const [usingFallback, setUsingFallback] = useState(false);

  useEffect(() => {
    // Check if user has liked the video
    if (videoId) {
      const hasLiked = localStorage.getItem(`liked-${videoId.toString()}`);
      if (hasLiked) {
        setIsLiked(true);
      }
    }
  }, [videoId]);

  // Log props for debugging
  useEffect(() => {
    console.log('VideoPlayer props:', {
      videoId: videoId ? videoId.toString() : 'undefined',
      title,
      mediaRef,
      thumbnailCid,
      hlsCid,
      duration,
      likes,
      views
    });
  }, [videoId, title, mediaRef, thumbnailCid, hlsCid, duration, likes, views]);

  // Handle video source selection - prefer direct video over HLS since HLS is not working
  const videoSource = mediaRef 
    ? getIpfsUrl(mediaRef)
    : (hlsCid ? getHlsUrl(hlsCid) : '');
  
  console.log('Video source URL:', videoSource);

  // Handle thumbnail
  const thumbnailUrl = thumbnailCid 
    ? getIpfsUrl(thumbnailCid) 
    : '/placeholder-thumbnail.jpg';
  
  console.log('Thumbnail URL:', thumbnailUrl);

  // Format duration
  const formatDuration = (seconds: number) => {
    if (isNaN(seconds)) {
      return '0:00';
    }
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };

  // Format view count
  const formatViews = (count: number) => {
    if (isNaN(count)) {
      return '0';
    } else if (count >= 1000000) {
      return `${(count / 1000000).toFixed(1)}M`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}K`;
    } else {
      return count.toString();
    }
  };

  // Handle video play/pause
  const togglePlay = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play().catch(err => {
          console.error('Error playing video:', err);
          setError('Could not play video. Please try again.');
        });
      }
      setIsPlaying(!isPlaying);
    }
  };

  // Handle like button click
  const handleLike = async () => {
    if (!isLiked && videoId) {
      try {
        // Call the backend to like the video
        const success = await likeVideo(videoId);
        if (success) {
          setLikeCount(prev => prev + 1);
          setIsLiked(true);
          localStorage.setItem(`liked-${videoId.toString()}`, 'true');
          if (onLike) onLike();
        }
      } catch (err) {
        console.error('Error liking video:', err);
      }
    }
  };

  // Handle time update
  const handleTimeUpdate = () => {
    if (videoRef.current) {
      setCurrentTime(videoRef.current.currentTime);
    }
  };

  // Handle video error
  const handleVideoError = () => {
    console.error('Video playback error. Source:', videoRef.current?.src);
    
    // If we're already using the direct video and it failed, show an error
    if (usingFallback || !hlsCid) {
      console.error('Direct video playback failed');
      setError('Failed to load video. Please try again later.');
      setLoading(false);
      return;
    }
    
    // If we're using HLS and it failed, try the direct video
    if (hlsCid && !usingFallback && mediaRef) {
      console.log('Falling back to direct video');
      setUsingFallback(true);
      if (videoRef.current) {
        const directUrl = getIpfsUrl(mediaRef);
        console.log('Setting fallback URL:', directUrl);
        videoRef.current.src = directUrl;
        videoRef.current.load(); // Force reload with new source
      }
    } else {
      setError('Failed to load video. Please try again later.');
      setLoading(false);
    }
  };

  return (
    <div className="video-player rounded-lg overflow-hidden bg-gray-900">
      {/* Video container */}
      <div className="relative aspect-video bg-black">
        <video
          ref={videoRef}
          src={usingFallback ? getIpfsUrl(mediaRef) : videoSource}
          poster={thumbnailUrl}
          className="w-full h-full object-contain"
          onTimeUpdate={handleTimeUpdate}
          onPlay={() => setIsPlaying(true)}
          onPause={() => setIsPlaying(false)}
          onLoadStart={() => setLoading(true)}
          onLoadedData={() => setLoading(false)}
          onError={handleVideoError}
          controls
        />
        
        {/* Loading indicator */}
        {loading && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
            <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-white"></div>
          </div>
        )}
        
        {/* Error message */}
        {error && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50">
            <div className="text-white bg-red-600 px-4 py-2 rounded">
              {error}
            </div>
          </div>
        )}
        
        {/* Fallback indicator */}
        {usingFallback && !error && !loading && (
          <div className="absolute top-2 right-2 bg-yellow-500 text-black text-xs px-2 py-1 rounded">
            Playing original video
          </div>
        )}
      </div>
      
      {/* Video info */}
      <div className="p-4 bg-white">
        <h3 className="text-xl font-bold mb-2">{title}</h3>
        
        <div className="flex justify-between items-center mb-4">
          <div className="text-gray-600 text-sm">
            {formatViews(views)} views • {formatDuration(duration)}
          </div>
          
          <div className="flex items-center">
            <button 
              onClick={handleLike}
              className={`flex items-center space-x-1 px-3 py-1 rounded-full ${
                isLiked ? 'bg-blue-100 text-blue-600' : 'bg-gray-100 hover:bg-gray-200'
              }`}
              disabled={isLiked}
            >
              <svg 
                xmlns="http://www.w3.org/2000/svg" 
                className="h-5 w-5" 
                viewBox="0 0 20 20" 
                fill={isLiked ? "currentColor" : "none"}
                stroke="currentColor"
                strokeWidth={isLiked ? "0" : "1.5"}
              >
                <path d="M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333v5.43a2 2 0 001.106 1.79l.05.025A4 4 0 008.943 18h5.416a2 2 0 001.962-1.608l1.2-6A2 2 0 0015.56 8H12V4a2 2 0 00-2-2 1 1 0 00-1 1v.667a4 4 0 01-.8 2.4L6.8 7.933a4 4 0 00-.8 2.4z" />
              </svg>
              <span>{likeCount}</span>
            </button>
            
            <button 
              onClick={() => {
                if (navigator.share) {
                  navigator.share({
                    title: title,
                    text: `Check out this video: ${title}`,
                    url: window.location.href,
                  })
                  .catch((error) => console.log('Error sharing:', error));
                } else {
                  // Fallback for browsers that don't support the Web Share API
                  navigator.clipboard.writeText(window.location.href)
                    .then(() => alert('Link copied to clipboard!'))
                    .catch(err => console.error('Could not copy link:', err));
                }
              }}
              className="flex items-center space-x-1 px-3 py-1 rounded-full bg-gray-100 hover:bg-gray-200 ml-2"
            >
              <svg 
                xmlns="http://www.w3.org/2000/svg" 
                className="h-5 w-5" 
                viewBox="0 0 20 20" 
                fill="none"
                stroke="currentColor"
                strokeWidth="1.5"
              >
                <path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z" />
              </svg>
              <span>Share</span>
            </button>
          </div>
        </div>
        
        {/* Video details/description would go here */}
        <div className="text-sm text-gray-700 mt-4 pt-4 border-t">
          <p>Video ID: {videoId ? videoId.toString() : 'N/A'}</p>
          <p className="truncate">IPFS CID: {mediaRef || 'N/A'}</p>
          {hlsCid && <p className="truncate">HLS CID: {hlsCid}</p>}
        </div>
      </div>
    </div>
  );
};

export default VideoPlayer;

================
File: src/bitobytes_frontend/src/components/VideoUploadForm.tsx
================
// src/bitobytes_frontend/src/components/VideoUploadForm.tsx

import React, { useState, useRef } from 'react';
import { getBackendActor } from '../utils/canisterUtils';
import { uploadToIpfs, generateVideoThumbnail } from '../utils/ipfs';

const MAX_VIDEO_SIZE_MB = 100; // Increased limit since we're using our own node
const MAX_VIDEO_DURATION_SEC = 300; //d 5 minutes

interface VideoUploadFormProps {
  onSuccess?: (videoId: bigint) => void;
  onError?: (error: string) => void;
}

const VideoUploadForm: React.FC<VideoUploadFormProps> = ({ onSuccess, onError }) => {
  const [title, setTitle] = useState('');
  const [videoFile, setVideoFile] = useState<File | null>(null);
  const [thumbnailFile, setThumbnailFile] = useState<File | null>(null);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [processingHls, setProcessingHls] = useState(false);
  const [processingStep, setProcessingStep] = useState('');
  const [duration, setDuration] = useState(0);
  const [errorMsg, setErrorMsg] = useState('');
  const videoRef = useRef<HTMLVideoElement>(null);
  
  // Handle video file selection
  const handleVideoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      setVideoFile(null);
      setDuration(0);
      return;
    }
    
    const file = files[0];
    const fileSizeMB = file.size / (1024 * 1024);
    
    // Check file size
    if (fileSizeMB > MAX_VIDEO_SIZE_MB) {
      setErrorMsg(`Video size (${fileSizeMB.toFixed(2)}MB) exceeds the maximum allowed (${MAX_VIDEO_SIZE_MB}MB)`);
      e.target.value = '';
      return;
    }
    
    // Reset error message
    setErrorMsg('');
    setVideoFile(file);
    
    // Get video duration
    const video = document.createElement('video');
    video.preload = 'metadata';
    video.onloadedmetadata = () => {
      if (video.duration > MAX_VIDEO_DURATION_SEC) {
        setErrorMsg(`Video duration (${video.duration.toFixed(1)}s) exceeds the maximum allowed (${MAX_VIDEO_DURATION_SEC}s)`);
        setVideoFile(null);
        e.target.value = '';
      } else {
        setDuration(video.duration);
        
        // Automatically generate thumbnail if not manually selected
        if (!thumbnailFile) {
          generateVideoThumbnail(file)
            .then(thumbnailBlob => {
              const thumbnailFile = new File([thumbnailBlob], `${file.name}-thumbnail.jpg`, { type: 'image/jpeg' });
              setThumbnailFile(thumbnailFile);
            })
            .catch(err => {
              console.error('Error generating thumbnail:', err);
              // Continue without thumbnail if generation fails
            });
        }
      }
    };
    video.src = URL.createObjectURL(file);
  };
  
  // Handle thumbnail file selection
  const handleThumbnailChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) {
      setThumbnailFile(null);
      return;
    }
    
    setThumbnailFile(files[0]);
  };
  
  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!videoFile) {
      setErrorMsg('Please select a video to upload');
      return;
    }
    
    if (!title) {
      setErrorMsg('Please enter a title for the video');
      return;
    }
    
    setErrorMsg('');
    setUploading(true);
    setProcessingStep('Uploading video to IPFS...');
    
    try {
      // Upload video to IPFS via Helia
      // The server will process the video for HLS streaming
      const formData = new FormData();
      formData.append('video', videoFile);
      
      // Simulate progress updates
      let progress = 0;
      const progressInterval = setInterval(() => {
        progress += 5;
        if (progress > 95) {
          clearInterval(progressInterval);
          progress = 95; // Wait for actual completion to show 100%
        }
        setUploadProgress(progress);
      }, 500);
      
      const response = await fetch(`${process.env.NEXT_PUBLIC_HELIA_API_URL || 'http://localhost:3001'}/upload`, {
        method: 'POST',
        body: formData,
      });
      
      clearInterval(progressInterval);
      setUploadProgress(100);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Failed to upload to IPFS: ${errorData.error || response.statusText}`);
      }
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error('Upload failed');
      }
      
      const videoCid = data.cid;
      const hlsCid = data.hlsCid || '';
      
      console.log('Video uploaded with CID:', videoCid);
      console.log('HLS content CID:', hlsCid || 'Not available');
      
      // Upload thumbnail to IPFS if available
      setProcessingStep('Processing thumbnail...');
      let thumbnailCid = '';
      if (thumbnailFile) {
        // Use the utility function for thumbnail upload
        thumbnailCid = await uploadToIpfs(thumbnailFile);
      }
      
      // Store metadata in the canister
      setProcessingStep('Storing metadata...');
      const actor = await getBackendActor();
      const videoId = await actor.addVideo(
        title,
        videoCid,        // mediaRef (IPFS CID for original video)
        thumbnailCid,    // IPFS CID for thumbnail
        hlsCid,          // IPFS CID for HLS content
        Math.round(duration)
      );
      
      console.log('Video metadata stored successfully:', videoId.toString());
      
      // Clear form after successful upload
      setTitle('');
      setVideoFile(null);
      setThumbnailFile(null);
      setUploadProgress(0);
      setProcessingStep('');
      
      // Call success callback if provided
      if (onSuccess) {
        onSuccess(videoId);
      }
      
    } catch (error) {
      console.error('Upload error:', error);
      setErrorMsg(`Upload failed: ${error instanceof Error ? error.message : String(error)}`);
      
      // Call error callback if provided
      if (onError) {
        onError(error instanceof Error ? error.message : String(error));
      }
    } finally {
      setUploading(false);
      setProcessingHls(false);
      setProcessingStep('');
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-4">Upload Video</h2>
      
      {errorMsg && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {errorMsg}
        </div>
      )}
      
      <form onSubmit={handleSubmit}>
        <div className="mb-4">
          <label htmlFor="title" className="block text-gray-700 font-medium mb-2">
            Title
          </label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={uploading}
            placeholder="Enter video title"
            required
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="video" className="block text-gray-700 font-medium mb-2">
            Video File
          </label>
          <input
            type="file"
            id="video"
            onChange={handleVideoChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            accept="video/*"
            disabled={uploading}
            required
          />
          {videoFile && (
            <div className="mt-2 text-sm text-gray-600">
              <p>File: {videoFile.name}</p>
              <p>Size: {(videoFile.size / (1024 * 1024)).toFixed(2)} MB</p>
              <p>Duration: {duration.toFixed(1)} seconds</p>
            </div>
          )}
          <p className="mt-1 text-xs text-gray-500">
            Maximum size: {MAX_VIDEO_SIZE_MB}MB, Maximum duration: {MAX_VIDEO_DURATION_SEC} seconds
          </p>
        </div>
        
        <div className="mb-4">
          <label htmlFor="thumbnail" className="block text-gray-700 font-medium mb-2">
            Thumbnail Image (Optional)
          </label>
          <input
            type="file"
            id="thumbnail"
            onChange={handleThumbnailChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            accept="image/*"
            disabled={uploading}
          />
          {thumbnailFile && (
            <div className="mt-2">
              <p className="text-sm text-gray-600">Thumbnail: {thumbnailFile.name}</p>
              <img 
                src={URL.createObjectURL(thumbnailFile)} 
                alt="Thumbnail preview" 
                className="mt-2 h-24 object-cover rounded"
              />
            </div>
          )}
          <p className="mt-1 text-xs text-gray-500">
            If not provided, a thumbnail will be generated automatically
          </p>
        </div>
        
        {uploading && (
          <div className="mb-4">
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div 
                className="bg-blue-600 h-2.5 rounded-full" 
                style={{ width: `${uploadProgress}%` }}
              ></div>
            </div>
            <p className="text-sm text-gray-600 mt-1">
              {processingStep || `Uploading: ${uploadProgress}% complete`}
            </p>
          </div>
        )}
        
        <button
          type="submit"
          disabled={uploading || !videoFile || !title}
          className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {uploading ? 'Processing...' : 'Upload Video'}
        </button>
      </form>
    </div>
  );
};

export default VideoUploadForm;

================
File: src/bitobytes_frontend/src/context/AuthContext.tsx
================
import { createContext, useContext } from 'react';

// Create a context for the SIWE authentication state
export const AuthContext = createContext<{
  isAuthenticated: boolean;
  isLoading: boolean;
  login: () => Promise<void>;
  logout: () => void;
}>({
  isAuthenticated: false,
  isLoading: true,
  login: async () => {},
  logout: () => {},
});

// Custom hook to use the auth context
export const useAuth = () => useContext(AuthContext);

================
File: src/bitobytes_frontend/src/context/AuthProvider.tsx
================
import React, { ReactNode, useEffect, useState } from 'react';
import { SiweIdentityProvider, useSiwe } from 'ic-siwe-js/react';
import { WagmiProvider } from 'wagmi';
import { config } from '../wagmi/wagmi.config';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AuthContext } from './AuthContext';
import dynamic from 'next/dynamic';

// Create a query client for React Query
const queryClient = new QueryClient();

// Props for the AuthProvider component
interface AuthProviderProps {
  children: ReactNode;
  canisterId: string;
}

// Internal provider that uses the SIWE hooks
const InternalAuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { 
    identity, 
    login: siweLogin, 
    clear, 
    isInitializing,
    loginStatus,
    prepareLoginStatus,
    isLoginSuccess,
    isLoginError,
    loginError,
    delegationChain
  } = useSiwe();

  // Derived authentication state
  const isAuthenticated = !!identity;
  const isLoading = isInitializing || loginStatus === 'logging-in';

  // Login function that wraps the SIWE login
  const login = async () => {
    try {
      console.log('Starting SIWE login process...');
      console.log('Current login status:', loginStatus);
      console.log('Current prepare login status:', prepareLoginStatus);
      console.log('Has identity:', !!identity);
      console.log('Has delegation chain:', !!delegationChain);
      
      // Call the SIWE login function
      await siweLogin();
      console.log('SIWE login function completed');
    } catch (error) {
      console.error('Login failed:', error);
      if (error instanceof Error) {
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
      }
    }
  };

  // Logout function
  const logout = () => {
    console.log('Logging out...');
    console.log('Current identity:', identity?.getPrincipal().toString());
    clear();
    console.log('Identity cleared');
  };

  // Log authentication state changes
  useEffect(() => {
    console.log('Auth state changed:', {
      isAuthenticated,
      isLoading,
      loginStatus,
      prepareLoginStatus,
      isLoginSuccess,
      isLoginError
    });
    
    if (isLoginSuccess) {
      console.log('Login successful');
      console.log('Identity principal:', identity?.getPrincipal().toString());
      console.log('Delegation chain expiration:', delegationChain?.delegations[0]?.delegation.expiration.toString());
    }
    
    if (isLoginError && loginError) {
      console.error('Login error:', loginError);
      console.error('Login error stack:', loginError.stack);
    }
  }, [isLoginSuccess, isLoginError, loginError, isAuthenticated, isLoading, loginStatus, prepareLoginStatus, identity, delegationChain]);

  return (
    <AuthContext.Provider value={{ isAuthenticated, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

// Main provider component that wraps all the necessary providers
const AuthProviderComponent: React.FC<AuthProviderProps> = ({ children, canisterId }) => {
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  
  // Ensure canisterId is available and log it for debugging
  console.log('SIWE canister ID:', canisterId);
  console.log('IC host:', host);
  
  if (!canisterId) {
    console.warn('No canisterId provided to AuthProvider');
  }

  // Setup localStorage debug option for more detailed logging
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('debug', 'ic-siwe-js:*');
    }
  }, []);

  // Log when the component mounts and unmounts
  useEffect(() => {
    console.log('AuthProvider mounted');
    return () => {
      console.log('AuthProvider unmounted');
    };
  }, []);

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <SiweIdentityProvider
          canisterId={canisterId}
          httpAgentOptions={{
            host,
            verifyQuerySignatures: false,
            fetchOptions: {
              credentials: 'omit',
            },
          }}
        >
          <InternalAuthProvider>
            {children}
          </InternalAuthProvider>
        </SiweIdentityProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
};

// Export a dynamic version of the AuthProvider that only runs on the client
export const AuthProvider = dynamic<AuthProviderProps>(
  () => Promise.resolve(AuthProviderComponent),
  { ssr: false }
);

================
File: src/bitobytes_frontend/src/context/index.tsx
================
import { AuthContext, useAuth } from './AuthContext';
import { AuthProvider } from './AuthProvider';

// Re-export the AuthContext, useAuth hook, and AuthProvider
export { AuthContext, useAuth, AuthProvider };

================
File: src/bitobytes_frontend/src/pages/api/v2/canister/[canisterId]/call.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { canisterId } = req.query;
    
    if (!canisterId || typeof canisterId !== 'string') {
      return res.status(400).json({ error: 'Invalid canister ID' });
    }

    // Log the request details for debugging
    console.log(`[API v2] Processing call request for canister: ${canisterId}`);
    
    // Determine the host based on environment
    const host = process.env.NODE_ENV === 'production'
      ? 'https://ic0.app'
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`[API v2] Using host: ${host}`);
    
    const agent = new HttpAgent({ 
      host,
      verifyQuerySignatures: false,
      fetchOptions: {
        credentials: 'omit',
      },
    });

    // Fetch the root key for local development
    if (host.includes('localhost') || host.includes('127.0.0.1')) {
      try {
        await agent.fetchRootKey();
        console.log('[API v2] Root key fetched successfully');
      } catch (err) {
        console.error('[API v2] Failed to fetch root key:', err);
        return res.status(500).json({ 
          error: 'Failed to fetch root key',
          message: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // Forward the request to the IC
    const url = `${agent.host}/api/v2/canister/${canisterId}/call`;
    console.log(`[API v2] Forwarding request to: ${url}`);
    
    // Check if the canister ID is the management canister
    const siweCanisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;
    if (canisterId === 'ryjl3-tyaaa-aaaaa-aaaba-cai') {
      console.log(`[API v2] Request is for management canister, redirecting to SIWE provider (${siweCanisterId})`);
      if (!siweCanisterId) {
        console.error('[API v2] NEXT_PUBLIC_SIWE_CANISTER_ID is not set! Cannot redirect management canister request.');
        return res.status(500).json({ 
          error: 'SIWE canister ID not configured',
          message: 'The SIWE canister ID is not set in the environment variables. Please run ./deploy-rust-siwe.sh to deploy the SIWE provider.'
        });
      }
      
      console.log(`[API v2] Redirecting to SIWE canister: ${siweCanisterId}`);
      try {
        const redirectUrl = `${agent.host}/api/v2/canister/${siweCanisterId}/call`;
        console.log(`[API v2] Redirect URL: ${redirectUrl}`);
        
        const response = await fetch(redirectUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/cbor',
          },
          body: req.body,
        });
        
        // Log the response status
        console.log(`[API v2] Redirected response status: ${response.status}`);
        
        // Get the response data
        const data = await response.arrayBuffer();
        
        // Set the content type to match the response
        res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
        
        // Send the response
        return res.status(response.status).send(Buffer.from(data));
      } catch (error) {
        console.error('[API v2] Error redirecting to SIWE canister:', error);
        return res.status(500).json({ 
          error: 'Failed to redirect to SIWE canister',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/cbor',
      },
      body: req.body,
    });

    // Log the response status
    console.log(`[API v2] Response status: ${response.status}`);
    
    // If the response is not successful, try to get more details
    if (!response.ok) {
      let errorText = '';
      try {
        errorText = await response.text();
      } catch (e) {
        errorText = 'Could not extract error text';
      }
      console.error(`[API v2] Error response: ${errorText}`);
      return res.status(response.status).json({ 
        error: 'Error from IC replica', 
        status: response.status,
        details: errorText
      });
    }

    // Get the response data
    const data = await response.arrayBuffer();
    
    // Set the content type to match the response
    res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
    
    // Send the response
    res.status(response.status).send(Buffer.from(data));
  } catch (error) {
    console.error('[API v2] Error proxying call request:', error);
    res.status(500).json({ 
      error: 'Failed to proxy call request',
      message: error instanceof Error ? error.message : String(error)
    });
  }
}

================
File: src/bitobytes_frontend/src/pages/api/v2/canister/[canisterId]/read_state.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { canisterId } = req.query;
    
    if (!canisterId || typeof canisterId !== 'string') {
      return res.status(400).json({ error: 'Invalid canister ID' });
    }

    // Log the request details for debugging
    console.log(`[API read_state] Processing request for canister: ${canisterId}`);
    
    // Determine the host based on environment
    const host = process.env.NODE_ENV === 'production'
      ? 'https://ic0.app'
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`[API read_state] Using host: ${host}`);
    
    const agent = new HttpAgent({ 
      host,
      verifyQuerySignatures: false,
      fetchOptions: {
        credentials: 'omit',
      },
    });

    // Fetch the root key for local development
    if (host.includes('localhost') || host.includes('127.0.0.1')) {
      try {
        await agent.fetchRootKey();
        console.log('[API read_state] Root key fetched successfully');
      } catch (err) {
        console.error('[API read_state] Failed to fetch root key:', err);
        return res.status(500).json({ 
          error: 'Failed to fetch root key',
          message: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // Forward the request to the IC
    const url = `${agent.host}/api/v2/canister/${canisterId}/read_state`;
    console.log(`[API read_state] Forwarding request to: ${url}`);
    
    // Check if the canister ID is the management canister
    const siweCanisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;
    if (canisterId === 'ryjl3-tyaaa-aaaaa-aaaba-cai') {
      console.log(`[API read_state] Request is for management canister, redirecting to SIWE provider (${siweCanisterId})`);
      if (!siweCanisterId) {
        console.error('[API read_state] NEXT_PUBLIC_SIWE_CANISTER_ID is not set! Cannot redirect management canister request.');
        return res.status(500).json({ 
          error: 'SIWE canister ID not configured',
          message: 'The SIWE canister ID is not set in the environment variables. Please run ./deploy-rust-siwe.sh to deploy the SIWE provider.'
        });
      }
      
      console.log(`[API read_state] Redirecting to SIWE canister: ${siweCanisterId}`);
      try {
        const redirectUrl = `${agent.host}/api/v2/canister/${siweCanisterId}/read_state`;
        console.log(`[API read_state] Redirect URL: ${redirectUrl}`);
        
        const response = await fetch(redirectUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/cbor',
          },
          body: req.body,
        });
        
        // Log the response status
        console.log(`[API read_state] Redirected response status: ${response.status}`);
        
        // Get the response data
        const data = await response.arrayBuffer();
        
        // Set the content type to match the response
        res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
        
        // Send the response
        return res.status(response.status).send(Buffer.from(data));
      } catch (error) {
        console.error('[API read_state] Error redirecting to SIWE canister:', error);
        return res.status(500).json({ 
          error: 'Failed to redirect to SIWE canister',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/cbor',
      },
      body: req.body,
    });

    // Log the response status
    console.log(`[API read_state] Response status: ${response.status}`);
    
    // If the response is not successful, try to get more details
    if (!response.ok) {
      let errorText = '';
      try {
        errorText = await response.text();
      } catch (e) {
        errorText = 'Could not extract error text';
      }
      console.error(`[API read_state] Error response: ${errorText}`);
      return res.status(response.status).json({ 
        error: 'Error from IC replica', 
        status: response.status,
        details: errorText
      });
    }

    // Get the response data
    const data = await response.arrayBuffer();
    
    // Set the content type to match the response
    res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
    
    // Send the response
    res.status(response.status).send(Buffer.from(data));
  } catch (error) {
    console.error('[API read_state] Error proxying request:', error);
    res.status(500).json({ 
      error: 'Failed to proxy read_state request',
      message: error instanceof Error ? error.message : String(error)
    });
  }
}

================
File: src/bitobytes_frontend/src/pages/api/v2/status.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';
import * as cbor from 'cbor';

// This endpoint is required by the ic-siwe-js library to check the status of the Internet Computer
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // Create an agent to connect to the local Internet Computer replica
    const agent = new HttpAgent({
      host: process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943',
    });

    // Fetch the root key since we're connecting to a local replica
    if (process.env.DFX_NETWORK !== 'ic') {
      await agent.fetchRootKey();
    }

    // Get the status directly from the agent
    const status = await agent.status();

    // Convert the status to CBOR format
    const cborData = cbor.encode(status);
    
    // Set the content type to application/cbor
    res.setHeader('Content-Type', 'application/cbor');
    res.status(200).send(Buffer.from(cborData));
  } catch (error) {
    console.error('Error fetching IC status:', error);
    res.status(500).json({ error: 'Failed to fetch IC status' });
  }
}

================
File: src/bitobytes_frontend/src/pages/api/v3/canister/[canisterId]/call.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { canisterId } = req.query;
    
    if (!canisterId || typeof canisterId !== 'string') {
      return res.status(400).json({ error: 'Invalid canister ID' });
    }

    // Log the request details for debugging
    console.log(`[API v3] Processing call request for canister: ${canisterId}`);
    
    // Determine the host based on environment
    const host = process.env.NODE_ENV === 'production'
      ? 'https://ic0.app'
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`[API v3] Using host: ${host}`);
    
    const agent = new HttpAgent({ 
      host,
      verifyQuerySignatures: false,
      fetchOptions: {
        credentials: 'omit',
      },
    });

    // Fetch the root key for local development
    if (host.includes('localhost') || host.includes('127.0.0.1')) {
      try {
        await agent.fetchRootKey();
        console.log('[API v3] Root key fetched successfully');
      } catch (err) {
        console.error('[API v3] Failed to fetch root key:', err);
        return res.status(500).json({ 
          error: 'Failed to fetch root key',
          message: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // Forward the request to the IC
    const url = `${agent.host}/api/v3/canister/${canisterId}/call`;
    console.log(`[API v3] Forwarding request to: ${url}`);
    
    // Check if the canister ID is the management canister
    const siweCanisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;
    if (canisterId === 'ryjl3-tyaaa-aaaaa-aaaba-cai') {
      console.log(`[API v3] Request is for management canister, redirecting to SIWE provider (${siweCanisterId})`);
      if (!siweCanisterId) {
        console.error('[API v3] NEXT_PUBLIC_SIWE_CANISTER_ID is not set! Cannot redirect management canister request.');
        return res.status(500).json({ 
          error: 'SIWE canister ID not configured',
          message: 'The SIWE canister ID is not set in the environment variables. Please run ./deploy-rust-siwe.sh to deploy the SIWE provider.'
        });
      }
      
      console.log(`[API v3] Redirecting to SIWE canister: ${siweCanisterId}`);
      try {
        const redirectUrl = `${agent.host}/api/v3/canister/${siweCanisterId}/call`;
        console.log(`[API v3] Redirect URL: ${redirectUrl}`);
        
        const response = await fetch(redirectUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/cbor',
          },
          body: req.body,
        });
        
        // Log the response status
        console.log(`[API v3] Redirected response status: ${response.status}`);
        
        // Get the response data
        const data = await response.arrayBuffer();
        
        // Set the content type to match the response
        res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
        
        // Send the response
        return res.status(response.status).send(Buffer.from(data));
      } catch (error) {
        console.error('[API v3] Error redirecting to SIWE canister:', error);
        return res.status(500).json({ 
          error: 'Failed to redirect to SIWE canister',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/cbor',
      },
      body: req.body,
    });

    // Log the response status
    console.log(`[API v3] Response status: ${response.status}`);
    
    // If the response is not successful, try to get more details
    if (!response.ok) {
      let errorText = '';
      try {
        errorText = await response.text();
      } catch (e) {
        errorText = 'Could not extract error text';
      }
      console.error(`[API v3] Error response: ${errorText}`);
      return res.status(response.status).json({ 
        error: 'Error from IC replica', 
        status: response.status,
        details: errorText
      });
    }

    // Get the response data
    const data = await response.arrayBuffer();
    
    // Set the content type to match the response
    res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
    
    // Send the response
    res.status(response.status).send(Buffer.from(data));
  } catch (error) {
    console.error('[API v3] Error proxying call request:', error);
    res.status(500).json({ 
      error: 'Failed to proxy v3 call request',
      message: error instanceof Error ? error.message : String(error)
    });
  }
}

================
File: src/bitobytes_frontend/src/pages/video/[id].tsx
================
import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import dynamic from 'next/dynamic';
import Navigation from '../../components/Navigation';
import VideoPlayer from '../../components/VideoPlayer';
import { getBackendActor, Video } from '../../utils/canisterUtils';
import { getIpfsUrl } from '../../utils/ipfs';

// Create a client-side only component
const VideoDetailComponent = () => {
  const router = useRouter();
  const { id } = router.query;
  
  const [video, setVideo] = useState<Video | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [relatedVideos, setRelatedVideos] = useState<Video[]>([]);

  useEffect(() => {
    // Fetch the specific video and related videos when the ID is available
    const fetchData = async () => {
      if (!id) return;
      
      setLoading(true);
      setError(null);
      
      try {
        console.log('Fetching video with ID:', id);
        const backendActor = await getBackendActor();
        
        // Convert ID string to bigint for the canister call
        let videoId: bigint;
        try {
          videoId = BigInt(id as string);
          console.log('Converted ID to BigInt:', videoId.toString());
          
          // Fetch the specific video
          console.log('Calling backend.getVideo with ID:', videoId.toString());
          const fetchedVideo = await backendActor.getVideo(videoId);
          console.log('Fetched video result:', fetchedVideo);
          
          if (!fetchedVideo) {
            console.error('Video not found for ID:', videoId.toString());
            setError('Video not found');
            setLoading(false);
            return;
          }
          
          // Check if fetchedVideo is an array (unexpected) and extract the first item if so
          let videoData;
          if (Array.isArray(fetchedVideo)) {
            console.log('Warning: getVideo returned an array instead of a single object');
            if (fetchedVideo.length > 0) {
              videoData = fetchedVideo[0];
            } else {
              console.error('Empty video array returned');
              setError('Video data is invalid');
              setLoading(false);
              return;
            }
          } else {
            videoData = fetchedVideo;
          }
          
          console.log('Setting video data:', videoData);
          setVideo(videoData);
        } catch (error) {
          const idErr = error as Error;
          console.error('Error converting ID to BigInt:', idErr);
          setError(`Invalid video ID: ${id}. Error: ${idErr.message}`);
          setLoading(false);
          return;
        }
        
        // Increment view count
        try {
          await backendActor.incrementViewCount(videoId);
        } catch (viewErr) {
          console.error('Error incrementing view count:', viewErr);
          // Don't fail the whole page load for this
        }
        
        // Fetch all videos to show related videos
        const allVideos = await backendActor.getVideos();
        
        // Filter out the current video and limit to 5 related videos
        const related = allVideos
          .filter(v => v.id.toString() !== id)
          .slice(0, 5);
        
        setRelatedVideos(related);
      } catch (err) {
        console.error('Error fetching video:', err);
        setError('Failed to load video. Please try again.');
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [id]);

  // Handle video like
  const handleLike = async () => {
    if (!video) return;
    
    try {
      // Refresh the video data to get updated like count
      const backendActor = await getBackendActor();
      const updatedVideo = await backendActor.getVideo(video.id);
      
      if (updatedVideo) {
        // Handle case where updatedVideo is an array
        if (Array.isArray(updatedVideo) && updatedVideo.length > 0) {
          setVideo(updatedVideo[0]);
        } else if (!Array.isArray(updatedVideo)) {
          setVideo(updatedVideo);
        }
      }
    } catch (err) {
      console.error('Error refreshing video data after like:', err);
    }
  };
  
  // Format the timestamp to a readable date
  const formatDate = (timestamp: bigint) => {
    const date = new Date(Number(timestamp) / 1000000); // Convert nanoseconds to milliseconds
    return date.toLocaleString();
  };

  return (
    <div>
      <Head>
        <title>{video ? `${video.title} - BitOBytes` : 'Loading Video - BitOBytes'}</title>
        <meta name="description" content={video ? `Watch ${video.title} on BitOBytes` : 'Watch videos on BitOBytes'} />
      </Head>

      <Navigation />

      <div className="container mx-auto p-4">
        {loading ? (
          <div className="flex justify-center items-center h-64">
            <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
          </div>
        ) : error ? (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        ) : video ? (
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Main video container - takes 2/3 of the screen on large displays */}
            <div className="lg:col-span-2">
              <VideoPlayer 
                videoId={video.id}
                title={video.title}
                mediaRef={video.mediaRef}
                thumbnailCid={video.thumbnailCid}
                hlsCid={video.hlsCid}
                duration={Number(video.duration)}
                likes={Number(video.likes)}
                views={Number(video.views)}
                onLike={handleLike}
              />

              {/* Video metadata */}
              <div className="mt-4 bg-white p-4 rounded-lg shadow">
                <h2 className="text-2xl font-bold">{video.title}</h2>
                <p className="text-gray-600 text-sm">
                  Uploaded on {video.timestamp ? formatDate(video.timestamp) : 'Unknown date'}
                </p>
                
                <div className="mt-4 pt-4 border-t">
                  <h3 className="font-semibold">About this video</h3>
                  <p className="mt-2 text-gray-700">
                    This video was uploaded to the Internet Computer and is stored on IPFS.
                  </p>
                  
                  <div className="mt-4 bg-gray-100 p-2 rounded text-xs font-mono overflow-auto">
                    <p>Video ID: {video.id ? video.id.toString() : 'N/A'}</p>
                    <p>Media CID: {video.mediaRef || 'N/A'}</p>
                    {video.hlsCid && <p>HLS CID: {video.hlsCid}</p>}
                  </div>
                </div>
              </div>
            </div>

            {/* Related videos sidebar - takes 1/3 of the screen on large displays */}
            <div>
              <h3 className="text-xl font-semibold mb-4">Related Videos</h3>
              
              {relatedVideos.length === 0 ? (
                <p className="text-gray-500">No related videos found.</p>
              ) : (
                <div className="space-y-4">
                  {relatedVideos.map((relatedVideo) => (
                    <div 
                      key={relatedVideo.id ? relatedVideo.id.toString() : 'unknown'} 
                      className="flex bg-white p-2 rounded-lg shadow cursor-pointer hover:bg-gray-50"
                      onClick={() => relatedVideo.id && router.push(`/video/${relatedVideo.id.toString()}`)}
                    >
                      {/* Thumbnail */}
                      <div className="w-40 h-24 bg-gray-200 rounded overflow-hidden flex-shrink-0">
                        {relatedVideo.thumbnailCid ? (
                          <img 
                            src={getIpfsUrl(relatedVideo.thumbnailCid)} 
                            alt={relatedVideo.title}
                            className="w-full h-full object-cover"
                            onError={(e) => {
                              e.currentTarget.src = '/placeholder-thumbnail.jpg';
                            }}
                          />
                        ) : (
                          <div className="w-full h-full flex items-center justify-center bg-gray-300">
                            <span className="text-gray-500 text-xs">No Thumbnail</span>
                          </div>
                        )}
                      </div>
                      
                      {/* Video info */}
                      <div className="ml-3 flex flex-col justify-between">
                        <div>
                          <h4 className="font-medium text-sm line-clamp-2">{relatedVideo.title}</h4>
                          <p className="text-xs text-gray-500 mt-1">
                            {relatedVideo.views ? `${relatedVideo.views.toString()} views` : 'No views'} • {relatedVideo.likes ? `${relatedVideo.likes.toString()} likes` : '0 likes'}
                          </p>
                        </div>
                        <p className="text-xs text-gray-400">
                          {relatedVideo.timestamp ? formatDate(relatedVideo.timestamp) : 'Unknown date'}
                        </p>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        ) : (
          <div className="bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded mb-4">
            No video ID specified. Please select a video to watch.
          </div>
        )}
      </div>
    </div>
  );
};

// Export a dynamic version that only runs on the client
export default dynamic(() => Promise.resolve(VideoDetailComponent), { ssr: false });

================
File: src/bitobytes_frontend/src/pages/_app.tsx
================
import '@/styles/globals.css';
import type { AppProps } from 'next/app';
import { AuthProvider } from '../context/index';
import { canisterId } from '../../../ic_siwe_provider/declarations/index';
import { patchFetch } from '../utils/rootKeyFetch';
import { useEffect } from 'react';

// Configure global settings for ic-js
if (typeof window !== 'undefined') {
  // Set up environment variables in the browser
  window.process = {
    ...window.process,
    env: {
      ...window.process?.env,
      NEXT_PUBLIC_SIWE_CANISTER_ID: process.env.NEXT_PUBLIC_SIWE_CANISTER_ID,
      NEXT_PUBLIC_BACKEND_CANISTER_ID: process.env.NEXT_PUBLIC_BACKEND_CANISTER_ID,
      NEXT_PUBLIC_FRONTEND_CANISTER_ID: process.env.NEXT_PUBLIC_FRONTEND_CANISTER_ID,
      NEXT_PUBLIC_IC_HOST: process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943',
    }
  };
  
  // Enable debug logging for ic-siwe-js
  localStorage.setItem('debug', 'ic-siwe-js:*');
}

export default function App({ Component, pageProps }: AppProps) {
  // Use environment variable directly as fallback to ensure consistency
  const siweCanisterId = canisterId || process.env.NEXT_PUBLIC_SIWE_CANISTER_ID || '';
  
  // Apply the fetch patch to ensure root key is fetched, but only on the client side
  useEffect(() => {
    if (typeof window !== 'undefined') {
      patchFetch();
    }
  }, []);
  
  if (!siweCanisterId) {
    console.error("WARNING: No SIWE canister ID available. Authentication will not work.");
    console.error("Please run ./deploy-rust-siwe.sh to deploy the SIWE provider and set the environment variable.");
  }
  
  return (
    <AuthProvider canisterId={siweCanisterId}>
      <Component {...pageProps} />
    </AuthProvider>
  );
}

================
File: src/bitobytes_frontend/src/pages/allProfiles.tsx
================
import React, { useEffect, useState } from 'react';
import Head from 'next/head';
import AuthGuard from '../AuthGuard';
import dynamic from 'next/dynamic';
import Navigation from '../components/Navigation';
import { getBackendActor, UserProfile } from '../utils/canisterUtils';

function AllProfilesPage() {
  const [profiles, setProfiles] = useState<UserProfile[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    (async () => {
      try {
        const actor = await getBackendActor();
        const list = await actor.listProfiles();
        setProfiles(list);
      } catch (err) {
        console.error('Error listing profiles:', err);
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  return (
    <AuthGuard>
      <>
        <Navigation />
        <div className="container mx-auto px-4 py-8">
          <Head>
            <title>All Profiles - BitOBytes</title>
          </Head>
          <h1 className="text-2xl font-bold mb-6">All User Profiles</h1>
          {loading ? (
            <p>Loading...</p>
          ) : profiles.length === 0 ? (
            <p>No profiles found.</p>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              {profiles.map((p) => (
                <div key={p.owner.toString()} className="border p-4 rounded">
                  <h2 className="font-semibold">{p.name}</h2>
                {p.avatarUrl && p.avatarUrl.trim() !== '' ? (
                  <img
                    src={p.avatarUrl}
                    alt="avatar"
                    className="h-16 w-16 mt-2 rounded"
                    onError={(e) => {
                      console.error('Error loading image:', e);
                      e.currentTarget.style.display = 'none';
                      if (e.currentTarget.parentElement) {
                        e.currentTarget.parentElement.innerHTML += '(image failed to load)';
                      }
                    }}
                  />
                ) : (
                  <div className="h-16 w-16 mt-2 rounded bg-gray-200 flex items-center justify-center text-gray-500">
                    No Image
                  </div>
                )}
                  <p className="text-sm text-gray-600 mt-2">
                    Principal: {p.owner.toString()}
                  </p>
                </div>
              ))}
            </div>
          )}
        </div>
      </>
    </AuthGuard>
  );
}

export default dynamic(() => Promise.resolve(AllProfilesPage), { ssr: false });

================
File: src/bitobytes_frontend/src/pages/index.tsx
================
import { useState, useEffect } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/router';
import { getBackendActor, Video } from '../utils/canisterUtils';
import Navigation from '../components/Navigation';
import { useAuth } from '../context/AuthContext';
import { getIpfsUrl } from '../utils/ipfs';
import dynamic from 'next/dynamic';

// Create a client-side only component
const HomeComponent = () => {
  const router = useRouter();
  const [videos, setVideos] = useState<Video[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { isAuthenticated } = useAuth();
  
  // Format duration from seconds to MM:SS
  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };
  
  // Format view count
  const formatViews = (count: number) => {
    if (count >= 1000000) {
      return `${(count / 1000000).toFixed(1)}M`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}K`;
    } else {
      return count.toString();
    }
  };
  
  // Format the timestamp to a readable date
  const formatDate = (timestamp: bigint) => {
    const date = new Date(Number(timestamp) / 1000000); // Convert nanoseconds to milliseconds
    return date.toLocaleDateString();
  };
  
  // Navigate to video detail page
  const navigateToVideo = (videoId: bigint) => {
    router.push(`/video/${videoId.toString()}`);
  };

  const fetchVideos = async () => {
    setLoading(true);
    setError(null);

    try {
      const backendActor = await getBackendActor();
      const fetchedVideos = await backendActor.getVideos();
      console.log('Fetched videos:', fetchedVideos);
      
      // Log more detailed information about each video
      fetchedVideos.forEach((video, index) => {
        console.log(`Video ${index}:`, {
          id: video.id.toString(),
          title: video.title,
          mediaRef: video.mediaRef,
          thumbnailCid: video.thumbnailCid,
          hlsCid: video.hlsCid,
          duration: video.duration.toString(),
          likes: video.likes.toString(),
          views: video.views.toString(),
          timestamp: video.timestamp.toString()
        });
      });
      
      setVideos(fetchedVideos);
    } catch (err) {
      console.error('Error fetching videos:', err);
      setError('Failed to fetch videos. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <Head>
        <title>BitOBytes - Decentralized Video Platform</title>
        <meta name="description" content="Decentralized TikTok-like platform on the Internet Computer" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Navigation />

      <div className="container mx-auto px-4">
        <main className="py-8">
          <div className="flex flex-col items-center justify-center mb-8">
            <h1 className="text-3xl font-bold mb-6">BitOBytes</h1>
            
            {isAuthenticated ? (
              <p className="mb-4 text-green-600">You are signed in with Ethereum!</p>
            ) : (
              <p className="mb-4 text-gray-600">Sign in with Ethereum to access all features.</p>
            )}
            
            <button 
              className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded"
              onClick={fetchVideos}
              disabled={loading}
            >
              {loading ? 'Loading...' : 'Fetch Videos'}
            </button>

            {error && (
              <p className="text-red-500 mt-4">{error}</p>
            )}
          </div>

          <div className="video-list">
            <h2 className="text-xl font-semibold mb-4">Videos</h2>
            
            {videos.length === 0 ? (
              <p className="text-gray-500">No videos found. Videos will appear here after fetching.</p>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {videos.map((video) => (
                  <div 
                    key={video.id.toString()} 
                    className="video-item bg-white shadow-md rounded-lg overflow-hidden cursor-pointer hover:shadow-lg transition-shadow"
                    onClick={() => navigateToVideo(video.id)}
                  >
                    {/* Thumbnail */}
                    <div className="relative aspect-video bg-gray-200">
                      {video.thumbnailCid ? (
                        <img 
                          src={getIpfsUrl(video.thumbnailCid)}
                          alt={video.title}
                          className="w-full h-full object-cover"
                          loading="lazy"
                          onError={(e) => {
                            e.currentTarget.src = '/placeholder-thumbnail.jpg';
                          }}
                        />
                      ) : (
                        <div className="w-full h-full flex items-center justify-center bg-gray-300">
                          <span className="text-gray-600">No Thumbnail</span>
                        </div>
                      )}
                      
                      {/* Duration badge */}
                      {video.duration > 0 && (
                        <div className="absolute bottom-2 right-2 bg-black bg-opacity-70 text-white text-xs px-1 py-0.5 rounded">
                          {formatDuration(Number(video.duration))}
                        </div>
                      )}
                    </div>
                    
                    {/* Video info */}
                    <div className="p-4">
                      <h3 className="text-lg font-medium line-clamp-2">{video.title}</h3>
                      <div className="flex justify-between mt-2">
                        <p className="text-sm text-gray-500">
                          {video.views ? formatViews(Number(video.views)) : '0'} views
                        </p>
                        <p className="text-sm text-gray-500 flex items-center">
                          <svg 
                            xmlns="http://www.w3.org/2000/svg" 
                            className="h-4 w-4 mr-1" 
                            viewBox="0 0 20 20" 
                            fill="currentColor"
                          >
                            <path d="M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333v5.43a2 2 0 001.106 1.79l.05.025A4 4 0 008.943 18h5.416a2 2 0 001.962-1.608l1.2-6A2 2 0 0015.56 8H12V4a2 2 0 00-2-2 1 1 0 00-1 1v.667a4 4 0 01-.8 2.4L6.8 7.933a4 4 0 00-.8 2.4z" />
                          </svg>
                          {video.likes.toString()}
                        </p>
                      </div>
                      <p className="text-xs text-gray-400 mt-2">
                        Uploaded on {formatDate(video.timestamp)}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </main>

        <footer className="mt-8 pt-8 border-t border-gray-200 text-center text-gray-500">
          <p>Powered by Internet Computer</p>
        </footer>
      </div>
    </div>
  );
};

// Export a dynamic version that only runs on the client
export default dynamic(() => Promise.resolve(HomeComponent), { ssr: false });

================
File: src/bitobytes_frontend/src/pages/profile.tsx
================
import React, { useEffect, useState } from 'react';
import Head from 'next/head';
import AuthGuard from '../AuthGuard';
import dynamic from 'next/dynamic';
import Navigation from '../components/Navigation';

import { useAccount } from 'wagmi';
import { useSiwe } from 'ic-siwe-js/react';
import { Principal } from '@dfinity/principal';
import { getBackendActor, Video, UserProfile } from '../utils/canisterUtils';

/** 
 * A simple "VideoCard" component 
 */
function VideoCard({ video }: { video: Video }) {
  return (
    <div className="border rounded p-4">
      <h3 className="font-semibold">{video.title}</h3>
      <p className="text-sm text-gray-600">Likes: {video.likes.toString()}</p>
      <p className="text-sm">MediaRef: {video.mediaRef}</p>
    </div>
  );
}

/**
 * A simple "EditProfile" form
 */
function EditProfile({
  profile,
  onSaved,
}: {
  profile: UserProfile | null;
  onSaved: (p: UserProfile) => void;
}) {
  const [name, setName] = useState(profile?.name || '');
  const [avatar, setAvatar] = useState(profile?.avatarUrl || '');
  const [saving, setSaving] = useState(false);
  const [imageValid, setImageValid] = useState<boolean | null>(null);
  
  // Function to validate image URL
  const validateImageUrl = (url: string) => {
    if (!url || url.trim() === '') {
      setImageValid(null);
      return;
    }
    
    const img = new Image();
    img.onload = () => setImageValid(true);
    img.onerror = () => setImageValid(false);
    img.src = url;
  };
  
  // Validate image URL when it changes
  useEffect(() => {
    validateImageUrl(avatar);
  }, [avatar]);

  async function handleSave(e: React.FormEvent) {
    e.preventDefault();
    setSaving(true);
    try {
      const actor = await getBackendActor();
      // Create the profile object locally to ensure type safety
      const profileToSave: UserProfile = {
        name,
        avatarUrl: avatar,
        owner: profile?.owner || Principal.anonymous() // Fallback to anonymous if no owner
      };
      
      // Save the profile to the backend
      await actor.saveMyProfile(name, avatar);
      
      // Use our local object for the state update
      onSaved(profileToSave);
    } catch (err) {
      console.error('Error saving profile:', err);
    } finally {
      setSaving(false);
    }
  }

  return (
    <form onSubmit={handleSave} className="p-4 bg-white rounded shadow-md">
      <div className="mb-4">
        <label className="block text-sm text-gray-600 mb-1">Name</label>
        <input
          type="text"
          className="border px-2 py-1 w-full"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm text-gray-600 mb-1">Avatar URL</label>
        <input
          type="text"
          className={`border px-2 py-1 w-full ${imageValid === false ? 'border-red-500' : ''}`}
          value={avatar}
          onChange={(e) => setAvatar(e.target.value)}
          placeholder="Enter a valid image URL"
        />
        {imageValid === false && (
          <p className="text-red-500 text-xs mt-1">
            This URL doesn't seem to be a valid image. Please check the URL.
          </p>
        )}
        {avatar && imageValid === true && (
          <div className="mt-2">
            <p className="text-green-500 text-xs">Image URL is valid!</p>
            <img 
              src={avatar} 
              alt="Avatar preview" 
              className="h-16 w-16 mt-1 rounded object-cover border"
            />
          </div>
        )}
      </div>

      <button
        type="submit"
        disabled={saving}
        className="bg-blue-600 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        {saving ? 'Saving...' : 'Save Profile'}
      </button>
    </form>
  );
}

const ProfilePage: React.FC = () => {
  const { address } = useAccount();
  const { identity, identityAddress } = useSiwe();

  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [myVideos, setMyVideos] = useState<Video[]>([]);
  const [loadingProfile, setLoadingProfile] = useState(true);
  const [loadingVideos, setLoadingVideos] = useState(true);

  useEffect(() => {
    let ignore = false;
    (async () => {
      if (!identity) return;

      // 1) Fetch user's profile
      setLoadingProfile(true);
      try {
        const actor = await getBackendActor();
        const result = await actor.getMyProfile();
        // Now result is either a UserProfile or null
        setProfile(result);
      } catch (err) {
        console.error('Error fetching profile:', err);
      } finally {
        setLoadingProfile(false);
      }

      // 2) Fetch user's own videos
      setLoadingVideos(true);
      try {
        const actor = await getBackendActor();
        const vids = await actor.getMyVideos();
        setMyVideos(vids);
      } catch (err) {
        console.error('Error fetching my videos:', err);
      } finally {
        setLoadingVideos(false);
      }
    })();

    return () => {
      ignore = true;
    };
  }, [identity]);

  function handleProfileSaved(updated: UserProfile) {
    setProfile(updated);
  }

  return (
    <AuthGuard>
      <>
        <Navigation />
        <div className="container mx-auto px-4 py-8">
          <Head>
            <title>Profile - BitOBytes</title>
          </Head>

          <h1 className="text-3xl font-bold mb-6">Your Profile</h1>

          {/* Basic info */}
          <div className="bg-white shadow-md rounded-lg p-6 mb-6">
            <h2 className="text-xl font-semibold mb-4">Ethereum / IC Info</h2>
            <p className="text-sm text-gray-500 mb-2">
              <strong>Connected ETH Address:</strong> {address}
            </p>
            <p className="text-sm text-gray-500 mb-2">
              <strong>SIWE Identity Address:</strong> {identityAddress}
            </p>
            <p className="text-sm text-gray-500 mb-2">
              <strong>IC Principal:</strong>{' '}
              {identity ? identity.getPrincipal().toString() : 'N/A'}
            </p>
          </div>

          {/* Profile */}
          <div className="mb-6">
            <h2 className="text-xl font-semibold mb-4">User Profile</h2>
            {loadingProfile ? (
              <p>Loading your profile...</p>
            ) : (
              <EditProfile profile={profile} onSaved={handleProfileSaved} />
            )}
            {profile && (
              <div className="mt-4 p-4 bg-gray-100 rounded">
                <p>
                  <strong>Name:</strong> {profile.name}
                </p>
                <p>
                  <strong>Avatar:</strong>{' '}
                  {profile.avatarUrl && profile.avatarUrl.trim() !== '' ? (
                    <img
                      src={profile.avatarUrl}
                      alt="avatar"
                      className="h-16 w-16 mt-1 rounded"
                      onError={(e) => {
                        console.error('Error loading image:', e);
                        e.currentTarget.style.display = 'none';
                        if (e.currentTarget.parentElement) {
                          e.currentTarget.parentElement.innerHTML += '(image failed to load)';
                        }
                      }}
                    />
                  ) : (
                    '(none)'
                  )}
                </p>
              </div>
            )}
          </div>

          {/* My Videos */}
          <div>
            <h2 className="text-xl font-semibold mb-4">My Uploaded Videos</h2>
            {loadingVideos ? (
              <p>Loading your videos...</p>
            ) : myVideos.length === 0 ? (
              <p>You haven't uploaded any videos yet.</p>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {myVideos.map((v) => (
                  <VideoCard key={v.id.toString()} video={v} />
                ))}
              </div>
            )}
          </div>
        </div>
      </>
    </AuthGuard>
  );
};

// Export a dynamic version so it only runs on the client
export default dynamic(() => Promise.resolve(ProfilePage), { ssr: false });

================
File: src/bitobytes_frontend/src/pages/signin.tsx
================
import React from 'react';
import Head from 'next/head';
import LoginPage from '../components/login/LoginPage';
import dynamic from 'next/dynamic';

// Create a client-side only component
const SignInComponent = () => {
  return (
    <div className="container mx-auto px-4 py-8">
      <Head>
        <title>Sign In - BitOBytes</title>
        <meta name="description" content="Sign in to BitOBytes with Ethereum" />
      </Head>

      <main>
        <LoginPage />
      </main>
    </div>
  );
};

// Export a dynamic version that only runs on the client
export default dynamic(() => Promise.resolve(SignInComponent), { ssr: false });

================
File: src/bitobytes_frontend/src/pages/upload.tsx
================
// src/bitobytes_frontend/src/pages/upload.tsx

import React, { useState } from 'react';
import Head from 'next/head';
import { useRouter } from 'next/router';
import dynamic from 'next/dynamic';
import Navigation from '../components/Navigation';
import { useAuth } from '../context/AuthContext';

// Use dynamic import with no SSR for the upload form
const VideoUploadForm = dynamic(() => import('../components/VideoUploadForm'), { ssr: false });

const UploadPage: React.FC = () => {
  const router = useRouter();
  const { isAuthenticated, isLoading } = useAuth();
  const [uploadSuccess, setUploadSuccess] = useState(false);
  const [uploadError, setUploadError] = useState('');
  
  // Handle upload success
  const handleUploadSuccess = (videoId: bigint) => {
    setUploadSuccess(true);
    setUploadError('');
    
    // Automatically redirect to home page after a delay
    setTimeout(() => {
      router.push('/');
    }, 3000);
  };
  
  // Handle upload error
  const handleUploadError = (error: string) => {
    setUploadError(error);
    setUploadSuccess(false);
  };
  
  return (
    <div>
      <Head>
        <title>Upload Video - BitOBytes</title>
        <meta name="description" content="Upload videos to BitOBytes" />
      </Head>
      
      <Navigation />
      
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6">Upload Video</h1>
        
        {isLoading ? (
          <div className="text-center py-8">
            <p>Loading...</p>
          </div>
        ) : !isAuthenticated ? (
          <div className="bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded">
            <p>You need to sign in to upload videos.</p>
            <button
              onClick={() => router.push('/signin')}
              className="mt-2 bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700"
            >
              Sign In
            </button>
          </div>
        ) : (
          <div className="max-w-2xl mx-auto">
            {uploadSuccess ? (
              <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4">
                <p>Video uploaded successfully! Redirecting to home page...</p>
              </div>
            ) : (
              <>
                <p className="mb-4 text-gray-700">
                  Upload your videos to BitOBytes. Your videos will be stored on IPFS via our
                  local Helia node and will be available to viewers instantly.
                </p>
                
                <VideoUploadForm
                  onSuccess={handleUploadSuccess}
                  onError={handleUploadError}
                />
              </>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

// Use dynamic import with no SSR for the entire page
export default dynamic(() => Promise.resolve(UploadPage), { ssr: false });

================
File: src/bitobytes_frontend/src/styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 0;
  border-bottom: 1px solid #e5e7eb;
}

.button {
  background-color: #3b82f6;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.button:hover {
  background-color: #2563eb;
}

.video-list {
  margin-top: 2rem;
}

.video-item {
  padding: 1rem;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  margin-bottom: 1rem;
}

================
File: src/bitobytes_frontend/src/types/next.d.ts
================
// Type declarations for Next.js modules
declare module 'next/app' {
  import { AppProps as NextAppProps } from 'next/dist/shared/lib/router/router';
  export type AppProps = NextAppProps;
}

declare module 'next/head' {
  import React from 'react';
  export default function Head(props: React.PropsWithChildren<{}>): JSX.Element;
}

declare module 'next/link' {
  import React from 'react';
  
  export interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
    href: string;
    as?: string;
    replace?: boolean;
    scroll?: boolean;
    shallow?: boolean;
    passHref?: boolean;
    prefetch?: boolean;
  }
  
  export default function Link(props: React.PropsWithChildren<LinkProps>): JSX.Element;
}

declare module 'next/router' {
  export interface RouterProps {
    pathname: string;
    query: Record<string, string | string[]>;
    asPath: string;
    push: (url: string, as?: string, options?: any) => Promise<boolean>;
    replace: (url: string, as?: string, options?: any) => Promise<boolean>;
    reload: () => void;
    back: () => void;
    prefetch: (url: string) => Promise<void>;
    beforePopState: (cb: (state: any) => boolean) => void;
    events: {
      on: (event: string, handler: (...args: any[]) => void) => void;
      off: (event: string, handler: (...args: any[]) => void) => void;
      emit: (event: string, ...args: any[]) => void;
    };
    isFallback: boolean;
    isReady: boolean;
  }
  
  export function useRouter(): RouterProps;
}

================
File: src/bitobytes_frontend/src/utils/agent.ts
================
import { HttpAgent } from '@dfinity/agent';

// Global agent instance
let globalAgent: HttpAgent | null = null;

// Global promise to track root key fetching
let rootKeyPromise: Promise<void> | null = null;

/**
 * Creates a properly configured HttpAgent for interacting with the Internet Computer
 * @param waitForRootKey Whether to wait for the root key to be fetched before returning
 * @returns A configured HttpAgent instance
 */
export async function createAgent(waitForRootKey = true): Promise<HttpAgent> {
  // If we already have a global agent, return it
  if (globalAgent) {
    // If we need to wait for the root key and it's being fetched, wait for it
    if (waitForRootKey && rootKeyPromise) {
      try {
        await rootKeyPromise;
      } catch (err) {
        console.error('Error waiting for root key:', err);
        // If there was an error, we'll create a new agent
        globalAgent = null;
      }
    }
    
    if (globalAgent) {
      return globalAgent;
    }
  }
  
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  console.log('Creating agent with host:', host);
  
  const agent = new HttpAgent({
    host,
    // Disable verification for local development
    verifyQuerySignatures: false,
    // Ensure fetches complete without credentials for CORS
    fetchOptions: {
      credentials: 'omit',
    },
  });
  
  // In a local development environment, we need to fetch the root key for verification
  if (host.includes('localhost') || host.includes('127.0.0.1')) {
    if (!rootKeyPromise) {
      // Create the promise only once
      rootKeyPromise = (async () => {
        try {
          console.log('Fetching root key...');
          // Add a custom header to identify this as a root key fetch to prevent infinite recursion
          await agent.fetchRootKey();
          console.log('Root key fetched successfully');
        } catch (err) {
          console.error('Failed to fetch root key:', err);
          // Reset the promise so we can try again
          rootKeyPromise = null;
          throw err;
        }
      })();
    }
    
    if (waitForRootKey) {
      try {
        // Wait for the root key to be fetched
        await rootKeyPromise;
        // Store the agent globally only after the root key is fetched
        globalAgent = agent;
      } catch (err) {
        console.error('Error waiting for root key:', err);
        throw err;
      }
    } else {
      // Store the agent globally even if we don't wait for the root key
      globalAgent = agent;
    }
  } else {
    // For production, store the agent globally
    globalAgent = agent;
  }
  
  return agent;
}

/**
 * Gets the global agent, creating it if necessary
 * @param waitForRootKey Whether to wait for the root key to be fetched before returning
 * @returns The global HttpAgent instance
 */
export async function getAgent(waitForRootKey = true): Promise<HttpAgent> {
  if (!globalAgent) {
    return createAgent(waitForRootKey);
  }
  
  return globalAgent;
}

/**
 * Ensures the root key is fetched for local development
 * @returns A promise that resolves when the root key is fetched
 */
export async function ensureRootKey(): Promise<void> {
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  
  if (host.includes('localhost') || host.includes('127.0.0.1')) {
    // This will create the agent and wait for the root key
    await createAgent(true);
  }
}

/**
 * Resets the global agent, forcing a new one to be created next time
 */
export function resetAgent(): void {
  globalAgent = null;
  rootKeyPromise = null;
}

================
File: src/bitobytes_frontend/src/utils/canisterUtils.ts
================
import { Actor, HttpAgent } from '@dfinity/agent';
import { Principal } from '@dfinity/principal';

// When deploying locally, we'll need to create this manually after "dfx generate"
// For now, we'll define the interface for TypeScript
export interface Video {
  id: bigint;
  uploader: Principal;
  title: string;
  mediaRef: string;
  thumbnailCid: string;
  hlsCid: string;
  duration: bigint;
  likes: bigint;
  views: bigint;
  timestamp: bigint;
}

export interface UserProfile {
  name: string;
  avatarUrl: string;
  owner: Principal;
}

export interface BitobytesBackend {
  // Existing video methods
  addVideo: (title: string, mediaRef: string, thumbnailCid: string, hlsCid: string, duration: number) => Promise<bigint>;
  getVideos: () => Promise<Video[]>;
  likeVideo: (videoId: bigint) => Promise<boolean>;
  
  // New video methods
  getVideo: (videoId: bigint) => Promise<Video | null>;
  incrementViewCount: (videoId: bigint) => Promise<boolean>;
  
  // Profile methods
  saveMyProfile: (name: string, avatarUrl: string) => Promise<UserProfile>;
  getMyProfile: () => Promise<UserProfile | null>; // Changed to match how we're using it
  listProfiles: () => Promise<UserProfile[]>;
  getMyVideos: () => Promise<Video[]>;
}

// Will be filled in by dfx generate after deployment
let canisterId: string;
let actor: BitobytesBackend;

export const initializeCanister = async () => {
  // When deploying locally
  const isLocalEnv = process.env.NODE_ENV !== 'production';
  
  try {
    const host = isLocalEnv ? 'http://localhost:4943' : 'https://ic0.app';
    const agent = new HttpAgent({ host });
    
    // When running locally, we need to fetch the root key
    if (isLocalEnv) {
      await agent.fetchRootKey();
    }

    // Use the correct canister ID from deployment
    canisterId = process.env.NEXT_PUBLIC_BACKEND_CANISTER_ID || '';
    
    // Once we have generated declarations, we'll replace this with properly typed Actor
    actor = Actor.createActor<BitobytesBackend>(
      // This will be filled in by the generated declarations
      ({ IDL }) => {
        const Video = IDL.Record({
          'id': IDL.Nat64,
          'uploader': IDL.Principal,
          'title': IDL.Text,
          'mediaRef': IDL.Text,
          'thumbnailCid': IDL.Text,
          'hlsCid': IDL.Text,
          'duration': IDL.Nat,
          'likes': IDL.Nat,
          'views': IDL.Nat,
          'timestamp': IDL.Int,
        });
        
        const UserProfile = IDL.Record({
          'name': IDL.Text,
          'avatarUrl': IDL.Text,
          'owner': IDL.Principal,
        });
        
        return IDL.Service({
          // Existing video methods
          'addVideo': IDL.Func([IDL.Text, IDL.Text, IDL.Text, IDL.Text, IDL.Nat], [IDL.Nat64], []),
          'getVideos': IDL.Func([], [IDL.Vec(Video)], ['query']),
          'likeVideo': IDL.Func([IDL.Nat64], [IDL.Bool], []),
          
          // New video methods
          'getVideo': IDL.Func([IDL.Nat64], [IDL.Opt(Video)], ['query']),
          'incrementViewCount': IDL.Func([IDL.Nat64], [IDL.Bool], []),
          
          // Profile methods
          'saveMyProfile': IDL.Func([IDL.Text, IDL.Text], [UserProfile], []),
          'getMyProfile': IDL.Func([], [IDL.Opt(UserProfile)], ['query']),
          'listProfiles': IDL.Func([], [IDL.Vec(UserProfile)], ['query']),
          'getMyVideos': IDL.Func([], [IDL.Vec(Video)], ['query']),
        });
      },
      { agent, canisterId }
    );
    
    return actor;
  } catch (error) {
    console.error('Error initializing canister:', error);
    throw error;
  }
};

export const getBackendActor = async (): Promise<BitobytesBackend> => {
  if (!actor) {
    await initializeCanister();
  }
  return actor;
};

/**
 * Like a video by its ID
 * @param videoId The ID of the video to like
 * @returns Promise resolving to a boolean indicating success
 */
export async function likeVideo(videoId: bigint): Promise<boolean> {
  try {
    const actor = await getBackendActor();
    return await actor.likeVideo(videoId);
  } catch (error) {
    console.error('Error liking video:', error);
    throw error;
  }
}

================
File: src/bitobytes_frontend/src/utils/ipfs.ts
================
// src/bitobytes_frontend/src/utils/ipfs.ts

/**
 * Utility functions for interacting with IPFS via the local Helia node
 */

// Helia node API URL from environment
const HELIA_API_URL = process.env.NEXT_PUBLIC_HELIA_API_URL || 'http://localhost:3001';

/**
 * Upload a file to IPFS via the local Helia node
 * @param file File to upload
 * @param onProgress Optional callback for progress updates
 * @returns Promise resolving to the IPFS CID
 */
export async function uploadToIpfs(
  file: File, 
  onProgress?: (progress: number) => void
): Promise<string> {
  // Create form data with the file
  const formData = new FormData();
  formData.append('video', file);
  
  try {
    // Implement a simple progress simulation since we don't have real progress from fetch
    if (onProgress) {
      let progress = 0;
      const interval = setInterval(() => {
        progress += 5;
        if (progress > 95) {
          clearInterval(interval);
          progress = 95; // Wait for actual completion to show 100%
        }
        onProgress(progress);
      }, 500);
    }
    
    // Send request to the Helia node
    const response = await fetch(`${HELIA_API_URL}/upload`, {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Failed to upload to IPFS: ${errorData.error || response.statusText}`);
    }
    
    const data = await response.json();
    
    // Upload complete - set progress to 100%
    if (onProgress) onProgress(100);
    
    return data.cid;
  } catch (error) {
    console.error('Error uploading to IPFS:', error);
    throw error;
  }
}

/**
 * Get the URL for accessing content from IPFS
 * @param cid IPFS CID of the content
 * @param path Optional path within a directory
 * @returns URL to access the content
 */
export function getIpfsUrl(cid: string, path?: string): string {
  if (!cid) return '';
  
  if (path) {
    return `${HELIA_API_URL}/ipfs/${cid}/${path}`;
  }
  return `${HELIA_API_URL}/ipfs/${cid}`;
}

/**
 * Get the URL for accessing HLS content from IPFS
 * @param hlsCid IPFS CID of the HLS directory
 * @returns URL to access the HLS master playlist
 */
export function getHlsUrl(hlsCid: string): string {
  if (!hlsCid) return '';
  return `${HELIA_API_URL}/ipfs/${hlsCid}/master.m3u8`;
}

/**
 * Generate a thumbnail from a video file
 * @param videoFile Video file to generate thumbnail from
 * @returns Promise resolving to a Blob containing the thumbnail image
 */
export async function generateVideoThumbnail(videoFile: File): Promise<Blob> {
  // Create a video element to load the file
  const video = document.createElement('video');
  const videoUrl = URL.createObjectURL(videoFile);
  
  return new Promise((resolve, reject) => {
    video.onloadeddata = async () => {
      try {
        // Seek to 25% of the video duration for the thumbnail
        video.currentTime = video.duration * 0.25;
      } catch (error) {
        URL.revokeObjectURL(videoUrl);
        reject(error);
      }
    };
    
    video.onseeked = () => {
      try {
        // Create a canvas to draw the thumbnail
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Draw the video frame to the canvas
        const ctx = canvas.getContext('2d');
        ctx!.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Clean up the video element
        URL.revokeObjectURL(videoUrl);
        
        // Convert the canvas to a blob
        canvas.toBlob((blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Failed to create thumbnail'));
          }
        }, 'image/jpeg', 0.8);
      } catch (error) {
        URL.revokeObjectURL(videoUrl);
        reject(error);
      }
    };
    
    video.onerror = () => {
      URL.revokeObjectURL(videoUrl);
      reject(new Error('Error loading video'));
    };
    
    // Load the video
    video.src = videoUrl;
    video.load();
  });
}

================
File: src/bitobytes_frontend/src/utils/rootKeyFetch.ts
================
import { HttpAgent } from '@dfinity/agent';

// Store the original fetch function
let originalFetch: typeof fetch | null = null;

// Flag to track if the root key has been fetched
let rootKeyFetched = false;

// Promise to track the root key fetching process
let rootKeyPromise: Promise<void> | null = null;

// Check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Initialize originalFetch in browser environment
if (isBrowser) {
  originalFetch = window.fetch;
}

/**
 * Ensures the root key is fetched for local development
 * @returns A promise that resolves when the root key is fetched
 */
export async function ensureRootKey(): Promise<void> {
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  
  // Only fetch the root key for local development
  if (!host.includes('localhost') && !host.includes('127.0.0.1')) {
    return;
  }
  
  // If the root key has already been fetched, return immediately
  if (rootKeyFetched) {
    return;
  }
  
  // If there's an existing promise, wait for it
  if (rootKeyPromise) {
    await rootKeyPromise;
    return;
  }
  
  // Create a new promise to fetch the root key
  rootKeyPromise = (async () => {
    try {
      console.log('Fetching root key for local development...');
      const agent = new HttpAgent({
        host,
        fetchOptions: { credentials: 'omit' }
      });
      await agent.fetchRootKey();
      console.log('Root key fetched successfully');
      rootKeyFetched = true;
    } catch (error) {
      console.error('Failed to fetch root key:', error);
      // Reset the promise so we can try again
      rootKeyPromise = null;
      throw error;
    }
  })();
  
  await rootKeyPromise;
}

// Flag to track if we're currently inside a fetch for the root key
let fetchingRootKey = false;

/**
 * Patches the global fetch function to ensure the root key is fetched before
 * making requests to the Internet Computer
 */
export function patchFetch(): void {
  // Only patch in the browser environment
  if (typeof window === 'undefined') {
    return;
  }
  
  // Only patch once
  if (window.fetch !== originalFetch) {
    return;
  }
  
  // Replace the global fetch function with our patched version
  window.fetch = async function patchedFetch(input, init) {
    // Check if this is a request to the Internet Computer
    const url = input instanceof Request ? input.url : String(input);
    const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    // If this is a request to the local Internet Computer and we're not already fetching the root key,
    // ensure the root key is fetched
    if (!fetchingRootKey && 
        (url.includes(host) || url.includes('/api/v2/') || url.includes('/api/v3/')) && 
        (host.includes('localhost') || host.includes('127.0.0.1'))) {
      
      // If the URL contains "fetch_root_key", we're fetching the root key
      if (url.includes('fetch_root_key')) {
        fetchingRootKey = true;
      } else {
        try {
          // Prevent recursive calls by checking if we're already fetching the root key
          if (!fetchingRootKey && rootKeyFetched === false) {
            fetchingRootKey = true;
            try {
              if (rootKeyPromise === null) {
                await ensureRootKey();
              } else if (rootKeyPromise) {
                await rootKeyPromise;
              }
            } finally {
              fetchingRootKey = false;
            }
          }
        } catch (error) {
          console.error('Failed to fetch root key before request:', error);
          // Continue with the request even if root key fetching fails
        }
      }
    }
    
    // Call the original fetch function
    if (!originalFetch) {
      console.error('Original fetch function is not available');
      return window.fetch(input, init);
    }
    
    try {
      return await originalFetch.call(window, input, init);
    } finally {
      // Reset the flag after the fetch is complete
      if (fetchingRootKey && url.includes('fetch_root_key')) {
        fetchingRootKey = false;
      }
    }
  };
  
  console.log('Patched fetch function to ensure root key is fetched');
}

/**
 * Restores the original fetch function
 */
export function restoreFetch(): void {
  if (typeof window !== 'undefined' && window.fetch !== originalFetch && originalFetch !== null) {
    window.fetch = originalFetch;
    console.log('Restored original fetch function');
  }
}

================
File: src/bitobytes_frontend/src/wagmi/is-chain-id-supported.tsx
================
import { wagmiChains } from './wagmi.config';

/**
 * Checks if a given chain ID is supported by the application
 * @param chainId The chain ID to check
 * @returns boolean indicating if the chain is supported
 */
export function isChainIdSupported(chainId: number): boolean {
  return wagmiChains.some((chain) => chain.id === chainId);
}

================
File: src/bitobytes_frontend/src/wagmi/wagmi.config.ts
================
import { createConfig, http } from 'wagmi';
import { mainnet, sepolia } from 'wagmi/chains';
import { injected, walletConnect } from 'wagmi/connectors';

// Create wagmi config with supported chains and connectors
export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [
    injected({
      shimDisconnect: true, // This helps with MetaMask disconnect issues
    }),
    walletConnect({
      // Using the provided projectId
      // In production, you should use an environment variable
      projectId: '3314f21eac8f71b9c7d0fd4b2ab0db7c',
    }),
  ],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
});

// Export the configured chains for use in other components
export const wagmiChains = [mainnet, sepolia];

================
File: src/bitobytes_frontend/src/AuthGuard.tsx
================
import React, { useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from './context/AuthContext';
import dynamic from 'next/dynamic';

interface AuthGuardProps {
  children: React.ReactNode;
}

/**
 * AuthGuard component to protect routes that require authentication
 * Redirects to signin page if user is not authenticated
 */
const AuthGuardComponent: React.FC<AuthGuardProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    // If authentication is still loading, do nothing
    if (isLoading) return;

    // If not authenticated and not already on the signin page, redirect to signin
    if (!isAuthenticated && router.pathname !== '/signin') {
      router.push('/signin');
    }
  }, [isAuthenticated, isLoading, router]);

  // Show loading state while checking authentication
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-screen">
        <div className="text-center">
          <div className="spinner mb-4"></div>
          <p>Loading authentication...</p>
        </div>
      </div>
    );
  }

  // If not authenticated, don't render children
  if (!isAuthenticated) {
    return null;
  }

  // If authenticated, render children
  return <>{children}</>;
};

// Export a dynamic version that only runs on the client
const AuthGuard = dynamic<AuthGuardProps>(
  () => Promise.resolve(AuthGuardComponent),
  { ssr: false }
);

export default AuthGuard;

================
File: src/bitobytes_frontend/src/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BitOBytes - Decentralized Video Platform</title>
  <meta name="description" content="Decentralized TikTok-like platform on the Internet Computer" />
  <link rel="icon" href="/favicon.ico" />
</head>
<body>
  <div id="root"></div>
</body>
</html>

================
File: src/bitobytes_frontend/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
package-lock.json

================
File: src/bitobytes_frontend/next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  // For local development, use local dist
  distDir: 'dist',
  // Comment out static export for development to enable API routes
  // output: 'export',
  images: {
    unoptimized: true,
  },
  // Used for static HTML exports for IC deployment
  trailingSlash: true,
  // Add rewrites for direct API access to the IC replica
  async rewrites() {
    // Determine the host based on environment
    const icHost = process.env.NODE_ENV === 'production' 
      ? 'https://ic0.app' 
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`Using IC host for rewrites: ${icHost}`);
    
    return [
      {
        source: '/api/:path*',
        destination: `${icHost}/api/:path*`,
      },
      // Add more specific rewrites with higher priority
      {
        source: '/api/v2/status',
        destination: `${icHost}/api/v2/status`,
      },
      {
        source: '/api/v2/canister/:canisterId/read_state',
        destination: `${icHost}/api/v2/canister/:canisterId/read_state`,
      },
      {
        source: '/api/v3/canister/:canisterId/call',
        destination: `${icHost}/api/v3/canister/:canisterId/call`,
      },
      // Special handling for the management canister
      {
        source: '/api/v2/canister/ryjl3-tyaaa-aaaaa-aaaba-cai/:path*',
        destination: `${icHost}/api/v2/canister/${process.env.NEXT_PUBLIC_SIWE_CANISTER_ID}/:path*`,
      },
    ];
  },
}

export default nextConfig

================
File: src/bitobytes_frontend/package.json
================
{
  "name": "bitobytes_frontend",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "export": "next build && rm -rf ../../dist/bitobytes_frontend/* && cp -r dist/* ../../dist/bitobytes_frontend/",
    "generate": "dfx generate",
    "clean": "rm -rf .next dist node_modules"
  },
  "dependencies": {
    "@dfinity/agent": "^2.3.0",
    "@dfinity/auth-client": "^2.3.0",
    "@dfinity/candid": "^2.3.0",
    "@dfinity/identity": "^2.3.0",
    "@dfinity/principal": "^2.3.0",
    "@tanstack/react-query": "^5.66.9",
    "@types/next": "^8.0.7",
    "@wagmi/connectors": "^5.7.8",
    "@wagmi/core": "^2.16.5",
    "@web3modal/ethereum": "^2.7.1",
    "@web3modal/wagmi": "^5.1.11",
    "cbor": "^10.0.3",
    "hls.js": "^1.5.20",
    "ic-siwe-js": "^0.2.4",
    "ipfs-http-client": "^60.0.1",
    "next": "^13.4.19",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "viem": "^2.23.5",
    "wagmi": "^2.14.12"
  },
  "devDependencies": {
    "@types/node": "^20.5.6",
    "@types/react": "^18.2.21",
    "@types/react-dom": "^18.2.7",
    "autoprefixer": "^10.4.15",
    "eslint": "^8.48.0",
    "eslint-config-next": "^13.4.19",
    "postcss": "^8.4.28",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.2.2"
  }
}

================
File: src/bitobytes_frontend/postcss.config.cjs
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: src/bitobytes_frontend/tailwind.config.cjs
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: src/bitobytes_frontend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "src/types/**/*.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

================
File: src/helia_node/temp/06214f4d-1886-4c46-8a4f-b27361272068/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/06214f4d-1886-4c46-8a4f-b27361272068/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/06214f4d-1886-4c46-8a4f-b27361272068/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/06214f4d-1886-4c46-8a4f-b27361272068/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/temp/07fc3ec0-903d-4954-951c-32f19610f4b2/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/07fc3ec0-903d-4954-951c-32f19610f4b2/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/07fc3ec0-903d-4954-951c-32f19610f4b2/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/07fc3ec0-903d-4954-951c-32f19610f4b2/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/temp/2ca0deb0-8a86-4e38-b09f-4ca6a4d172f3/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/2ca0deb0-8a86-4e38-b09f-4ca6a4d172f3/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/2ca0deb0-8a86-4e38-b09f-4ca6a4d172f3/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/2ca0deb0-8a86-4e38-b09f-4ca6a4d172f3/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/temp/39a3f9fc-6cdb-435a-a0bb-77f7dc3a4880/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/39a3f9fc-6cdb-435a-a0bb-77f7dc3a4880/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/39a3f9fc-6cdb-435a-a0bb-77f7dc3a4880/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/39a3f9fc-6cdb-435a-a0bb-77f7dc3a4880/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/temp/4de293dc-a144-4067-82df-2fa09b3a9433/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/4de293dc-a144-4067-82df-2fa09b3a9433/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/4de293dc-a144-4067-82df-2fa09b3a9433/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/4de293dc-a144-4067-82df-2fa09b3a9433/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/temp/5fba6c54-e78e-4d2e-8788-f22cd2fa19de/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/5fba6c54-e78e-4d2e-8788-f22cd2fa19de/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/5fba6c54-e78e-4d2e-8788-f22cd2fa19de/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/5fba6c54-e78e-4d2e-8788-f22cd2fa19de/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/temp/951a93a4-dd3c-4ef5-9f2d-0c20e8571911/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/951a93a4-dd3c-4ef5-9f2d-0c20e8571911/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/951a93a4-dd3c-4ef5-9f2d-0c20e8571911/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:4.800000,
segment_000.ts
#EXTINF:3.200000,
segment_001.ts
#EXTINF:4.800000,
segment_002.ts
#EXTINF:3.200000,
segment_003.ts
#EXTINF:4.800000,
segment_004.ts
#EXTINF:3.200000,
segment_005.ts
#EXTINF:4.800000,
segment_006.ts
#EXTINF:3.200000,
segment_007.ts
#EXTINF:4.800000,
segment_008.ts
#EXTINF:3.200000,
segment_009.ts
#EXTINF:4.800000,
segment_010.ts
#EXTINF:3.200000,
segment_011.ts
#EXTINF:4.800000,
segment_012.ts
#EXTINF:3.200000,
segment_013.ts
#EXTINF:2.100000,
segment_014.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/951a93a4-dd3c-4ef5-9f2d-0c20e8571911/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/temp/b065030a-8d29-4b9c-9b2b-9da60c9be8f9/360p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/b065030a-8d29-4b9c-9b2b-9da60c9be8f9/480p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/b065030a-8d29-4b9c-9b2b-9da60c9be8f9/720p/playlist.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:0
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
#EXTINF:0.040000,
segment_000.ts
#EXT-X-ENDLIST

================
File: src/helia_node/temp/b065030a-8d29-4b9c-9b2b-9da60c9be8f9/master.m3u8
================
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720,NAME="720p"
720p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480,NAME="480p"
480p/playlist.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=500000,RESOLUTION=640x360,NAME="360p"
360p/playlist.m3u8

================
File: src/helia_node/.gitignore
================
package-lock.json
.env
node_modules
blockstore/data/

================
File: src/helia_node/package.json
================
{
  "name": "bitobytes-helia-node",
  "version": "1.0.0",
  "description": "Helia IPFS node for BitOBytes",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [
    "ipfs",
    "helia",
    "bitobytes"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@helia/unixfs": "^4.0.2",
    "blockstore-fs": "^2.0.2",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "ffmpeg-static": "^4.4.0",
    "fluent-ffmpeg": "^2.1.2",
    "fs-extra": "^11.1.1",
    "helia": "^5.2.1",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "multiformats": "^13.3.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  }
}

================
File: src/helia_node/server.js
================
import { createHelia } from 'helia';
import { unixfs } from '@helia/unixfs';
import { FsBlockstore } from 'blockstore-fs';
import express from 'express';
import cors from 'cors';
import morgan from 'morgan';
import multer from 'multer';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import { CID } from 'multiformats/cid';
import ffmpeg from 'fluent-ffmpeg';
import ffmpegPath from 'ffmpeg-static';
import fsExtra from 'fs-extra';
import { createWriteStream } from 'fs';
import { randomUUID } from 'crypto';

// Load environment variables
dotenv.config();

// Setup paths for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create express app
const app = express();
const PORT = process.env.PORT || 3001;

// Configure middleware
app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

// Configure file upload
const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: { fileSize: 200 * 1024 * 1024 } // 200MB limit
});

// Set ffmpeg path
ffmpeg.setFfmpegPath(ffmpegPath);

// Create temp directory for HLS processing
const TEMP_DIR = path.join(__dirname, 'temp');
fsExtra.ensureDirSync(TEMP_DIR);

// Initialize the IPFS node
let helia;
let fs;

// HLS quality variants
const HLS_VARIANTS = [
  { name: '720p', resolution: '1280x720', bitrate: '2500k' },
  { name: '480p', resolution: '854x480', bitrate: '1000k' },
  { name: '360p', resolution: '640x360', bitrate: '500k' }
];

/**
 * Transcode a video file to HLS format with multiple quality variants
 * @param {Buffer} videoBuffer - The video file buffer
 * @returns {Promise<string>} - Path to the HLS directory
 */
async function transcodeToHls(videoBuffer) {
  // Create a unique directory for this transcoding job
  const jobId = randomUUID();
  const hlsDir = path.join(TEMP_DIR, jobId);
  await fsExtra.ensureDir(hlsDir);
  
  // Write the buffer to a temporary file
  const inputPath = path.join(hlsDir, 'input.mp4');
  await fsExtra.writeFile(inputPath, videoBuffer);
  
  // Create variant directories
  for (const variant of HLS_VARIANTS) {
    await fsExtra.ensureDir(path.join(hlsDir, variant.name));
  }
  
  // Process each quality variant
  const variantPromises = HLS_VARIANTS.map(variant => {
    return new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .outputOptions([
          '-profile:v main',
          '-preset veryfast',
          '-sc_threshold 0',
          '-g 48',                   // Keyframe interval
          '-keyint_min 48',          // Minimum keyframe interval
          '-hls_time 4',             // Segment duration in seconds
          '-hls_playlist_type vod',  // Video on demand playlist
          '-hls_segment_filename',   // Segment filename format
          path.join(hlsDir, variant.name, 'segment_%03d.ts')
        ])
        .outputOption('-b:v', variant.bitrate)  // Video bitrate
        .outputOption('-maxrate', variant.bitrate)
        .outputOption('-bufsize', variant.bitrate)
        .outputOption('-s', variant.resolution)  // Resolution
        .outputOption('-c:a', 'aac')            // Audio codec
        .outputOption('-b:a', '128k')           // Audio bitrate
        .output(path.join(hlsDir, variant.name, 'playlist.m3u8'))
        .on('start', (cmd) => {
          console.log(`Starting FFmpeg for ${variant.name} with command: ${cmd}`);
        })
        .on('progress', (progress) => {
          console.log(`[${variant.name}] Processing: ${progress.percent}% done`);
        })
        .on('end', () => {
          console.log(`Finished processing ${variant.name} variant`);
          resolve();
        })
        .on('error', (err) => {
          console.error(`Error processing ${variant.name} variant:`, err);
          reject(err);
        })
        .run();
    });
  });
  
  // Wait for all variants to be processed
  await Promise.all(variantPromises);
  
  // Create master playlist
  const masterPlaylist = '#EXTM3U\n#EXT-X-VERSION:3\n';
  const variantEntries = HLS_VARIANTS.map(variant => {
    const bandwidth = parseInt(variant.bitrate.replace('k', '000'));
    const [width, height] = variant.resolution.split('x');
    return `#EXT-X-STREAM-INF:BANDWIDTH=${bandwidth},RESOLUTION=${variant.resolution},NAME="${variant.name}"\n${variant.name}/playlist.m3u8`;
  });
  
  await fsExtra.writeFile(
    path.join(hlsDir, 'master.m3u8'),
    masterPlaylist + variantEntries.join('\n')
  );
  
  // Clean up input file
  await fsExtra.remove(inputPath);
  
  return hlsDir;
}

/**
 * Add a directory to IPFS recursively
 * @param {string} dirPath - Path to the directory
 * @returns {Promise<string>} - CID of the directory
 */
async function addDirectoryToIpfs(dirPath) {
  console.log(`Adding directory to IPFS: ${dirPath}`);
  
  // Get all files in the directory recursively
  const files = await fsExtra.readdir(dirPath, { withFileTypes: true });
  const entries = [];
  
  for (const file of files) {
    const fullPath = path.join(dirPath, file.name);
    
    if (file.isDirectory()) {
      // Recursively add subdirectory
      const subDirCid = await addDirectoryToIpfs(fullPath);
      entries.push({
        name: file.name,
        cid: CID.parse(subDirCid)
      });
    } else {
      // Add file
      const fileData = await fsExtra.readFile(fullPath);
      const cid = await fs.addBytes(new Uint8Array(fileData));
      entries.push({
        name: file.name,
        cid: cid
      });
    }
  }
  
  // Create directory with entries
  const dirCid = await fs.addDirectory(entries);
  console.log(`Directory added with CID: ${dirCid.toString()}`);
  
  return dirCid.toString();
}

async function initializeHelia() {
  try {
    console.log('Initializing Helia node...');
    
    // Initialize a filesystem-backed block store
    const blockstore = new FsBlockstore(path.join(__dirname, 'blockstore/data'));
    
    // Create a Helia IPFS node
    helia = await createHelia({ blockstore });
    fs = unixfs(helia);
    
    console.log('Helia node initialized with PeerID:', helia.libp2p.peerId.toString());
  } catch (error) {
    console.error('Error initializing Helia:', error);
    process.exit(1);
  }
}

// Define routes
app.get('/', (req, res) => {
  res.send('BitOBytes Helia Node is running');
});

// Upload route
app.post('/upload', upload.single('video'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No video file uploaded' });
  }

  try {
    console.log('Processing file:', req.file.originalname, 'Size:', req.file.size);
    
    const fileBuffer = req.file.buffer;
    console.log('File buffer size:', fileBuffer.length);
    
    // Upload original video to IPFS
    console.log('Adding original file to IPFS...');
    const originalCid = await fs.addBytes(new Uint8Array(fileBuffer));
    console.log('Original file added with CID:', originalCid.toString());
    
    // Process video for HLS streaming
    console.log('Processing video for HLS streaming...');
    let hlsCid = null;
    
    try {
      // Transcode video to HLS
      const hlsDir = await transcodeToHls(fileBuffer);
      
      // Add HLS directory to IPFS
      hlsCid = await addDirectoryToIpfs(hlsDir);
      
      // Clean up temporary directory
      await fs.remove(hlsDir);
      
      console.log('HLS processing complete. HLS CID:', hlsCid);
    } catch (hlsError) {
      console.error('Error processing HLS:', hlsError);
      // Continue with original video if HLS processing fails
    }
    
    console.log('Video upload and processing complete');
    
    res.json({
      success: true,
      cid: originalCid.toString(),
      hlsCid: hlsCid,
      filename: req.file.originalname,
      size: req.file.size
    });
  } catch (error) {
    console.error('Error uploading to IPFS:', error);
    res.status(500).json({ 
      error: 'Failed to upload to IPFS', 
      details: error.message,
      stack: error.stack
    });
  }
});

// Retrieve content by CID
app.get('/ipfs/:cid', async (req, res) => {
  try {
    const cidStr = req.params.cid;
    console.log(`Retrieving content for CID: ${cidStr}`);
    
    // Parse string CID to CID object if needed
    const cid = CID.parse(cidStr);
    
    // Get path from query parameter if provided
    const pathParam = req.query.path || '';
    
    // Determine content type based on file extension
    let contentType = 'application/octet-stream';
    
    if (pathParam.endsWith('.m3u8')) {
      contentType = 'application/vnd.apple.mpegurl';
    } else if (pathParam.endsWith('.ts')) {
      contentType = 'video/MP2T';
    } else if (pathParam.endsWith('.mp4')) {
      contentType = 'video/mp4';
    } else if (pathParam.endsWith('.jpg') || pathParam.endsWith('.jpeg')) {
      contentType = 'image/jpeg';
    } else if (pathParam.endsWith('.png')) {
      contentType = 'image/png';
    }
    
    // Set response headers
    res.setHeader('Content-Type', contentType);
    res.setHeader('Access-Control-Allow-Origin', '*');
    
    // Stream chunks directly to HTTP response
    for await (const chunk of fs.cat(cid)) {
      res.write(chunk);
    }
    res.end();
    console.log(`Successfully served content for CID: ${cidStr}, path: ${pathParam}`);
  } catch (error) {
    console.error('Error retrieving content:', error);
    res.status(500).send(`Error retrieving content: ${error.message}`);
  }
});

// Retrieve content from IPFS directory
app.get('/ipfs/:cid/:path(*)', async (req, res) => {
  try {
    const cidStr = req.params.cid;
    const pathParam = req.params.path;
    console.log(`Retrieving content for CID: ${cidStr}, path: ${pathParam}`);
    
    // Parse string CID to CID object
    const cid = CID.parse(cidStr);
    
    // Determine content type based on file extension
    let contentType = 'application/octet-stream';
    
    if (pathParam.endsWith('.m3u8')) {
      contentType = 'application/vnd.apple.mpegurl';
    } else if (pathParam.endsWith('.ts')) {
      contentType = 'video/MP2T';
    } else if (pathParam.endsWith('.mp4')) {
      contentType = 'video/mp4';
    } else if (pathParam.endsWith('.jpg') || pathParam.endsWith('.jpeg')) {
      contentType = 'image/jpeg';
    } else if (pathParam.endsWith('.png')) {
      contentType = 'image/png';
    }
    
    // Set response headers
    res.setHeader('Content-Type', contentType);
    res.setHeader('Access-Control-Allow-Origin', '*');
    
    // Get the file from the directory
    try {
      // Resolve the path within the directory
      const pathParts = pathParam.split('/').filter(Boolean);
      let currentCid = cid;
      
      // Navigate through the directory structure
      for (let i = 0; i < pathParts.length; i++) {
        const part = pathParts[i];
        const entries = [];
        
        // List directory entries
        for await (const entry of fs.ls(currentCid)) {
          entries.push(entry);
        }
        
        // Find the matching entry
        const matchingEntry = entries.find(entry => entry.name === part);
        
        if (!matchingEntry) {
          throw new Error(`Path not found: ${part}`);
        }
        
        currentCid = matchingEntry.cid;
      }
      
      // Stream the file content
      for await (const chunk of fs.cat(currentCid)) {
        res.write(chunk);
      }
      res.end();
      console.log(`Successfully served content for CID: ${cidStr}, path: ${pathParam}`);
    } catch (error) {
      console.error('Error resolving path:', error);
      res.status(404).send(`Path not found: ${pathParam}`);
    }
  } catch (error) {
    console.error('Error retrieving content:', error);
    res.status(500).send(`Error retrieving content: ${error.message}`);
  }
});

// Start the server
async function startServer() {
  await initializeHelia();
  
  app.listen(PORT, () => {
    console.log(`Helia node API server running at http://localhost:${PORT}`);
  });
}

startServer().catch(console.error);

================
File: src/ic_siwe_provider/declarations/index.js
================
// This file contains the canister ID for the SIWE provider
// In a production environment, this would be the actual canister ID
// For local development, we'll use the environment variable set by deploy-rust-siwe.sh

// Use the environment variable if available, otherwise use a placeholder
// Note: The placeholder will not work until the canister is deployed
export const canisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;

// Log the canister ID for debugging
if (!canisterId) {
  console.error("WARNING: NEXT_PUBLIC_SIWE_CANISTER_ID is not set!");
  console.error("Please run ./deploy-rust-siwe.sh to deploy the SIWE provider and set the environment variable.");
} else {
  console.log("SIWE Provider Canister ID:", canisterId);
}

================
File: src/ic_siwe_provider/main.mo
================
import Principal "mo:base/Principal";
import Text "mo:base/Text";
import Time "mo:base/Time";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Array "mo:base/Array";
import Option "mo:base/Option";
import Debug "mo:base/Debug";
import Nat "mo:base/Nat";
import Nat64 "mo:base/Nat64";
import Hash "mo:base/Hash";
import Error "mo:base/Error";
import Int "mo:base/Int";

actor SiweProvider {
  // Type definitions
  public type SiweMessage = {
    domain : Text;
    address : Text;
    statement : Text;
    uri : Text;
    version : Text;
    chainId : Nat;
    nonce : Text;
    issuedAt : Text;
    expirationTime : ?Text;
    notBefore : ?Text;
    requestId : ?Text;
    resources : [Text];
  };

  public type SignedMessage = {
    message : SiweMessage;
    signature : Text;
  };

  public type Identity = {
    address : Text;
    expiration : Int;
    delegations : [Delegation];
  };

  public type Delegation = {
    pubkey : [Nat8];
    expiration : Int;
    targets : ?[Principal];
  };

  // Storage for identities
  private stable var identitiesEntries : [(Text, Identity)] = [];
  private var identities = HashMap.HashMap<Text, Identity>(0, Text.equal, Text.hash);

  // Initialize from stable storage
  system func preupgrade() {
    identitiesEntries := Iter.toArray(identities.entries());
  };

  system func postupgrade() {
    identities := HashMap.fromIter<Text, Identity>(identitiesEntries.vals(), 10, Text.equal, Text.hash);
    identitiesEntries := [];
  };

  // Environment configuration
  private stable var productionDomain : Text = "bitobytes.icp";
  private stable var productionUri : Text = "https://bitobytes.icp";
  private stable var developmentDomain : Text = "localhost:3000";
  private stable var developmentUri : Text = "http://localhost:3000";
  
  // Generate a SIWE message for the given address with optional environment parameters
  public func generateSiweMessage(
    address : Text, 
    customDomain : ?Text, 
    customUri : ?Text,
    isProduction : ?Bool
  ) : async SiweMessage {
    let nonce = generateNonce();
    let currentTime = Time.now();
    let issuedAt = Int.toText(currentTime);
    
    // Determine which domain and URI to use based on parameters
    let domain = switch (customDomain, isProduction) {
      case (?d, _) { d }; // Custom domain takes precedence
      case (null, ?false) { developmentDomain };
      case (null, ?true) { productionDomain };
      case (null, null) { productionDomain }; // Default to production
    };
    
    let uri = switch (customUri, isProduction) {
      case (?u, _) { u }; // Custom URI takes precedence
      case (null, ?false) { developmentUri };
      case (null, ?true) { productionUri };
      case (null, null) { productionUri }; // Default to production
    };
    
    // Create a SIWE message
    let message : SiweMessage = {
      domain = domain;
      address = address;
      statement = "Sign in with Ethereum to BitOBytes on the Internet Computer";
      uri = uri;
      version = "1";
      chainId = 1; // Ethereum mainnet
      nonce = nonce;
      issuedAt = issuedAt;
      expirationTime = ?Int.toText(currentTime + 3600 * 1000 * 1000 * 1000); // 1 hour expiration
      notBefore = null;
      requestId = null;
      resources = [];
    };
    
    return message;
  };
  
  // Convenience method for generating a SIWE message with production settings
  public func generateProductionSiweMessage(address : Text) : async SiweMessage {
    await generateSiweMessage(address, null, null, ?true);
  };
  
  // Convenience method for generating a SIWE message with local development settings
  public func generateLocalSiweMessage(address : Text) : async SiweMessage {
    await generateSiweMessage(address, null, null, ?false);
  };

  // Verify a signed message and create a delegation
  public shared(msg) func verifySiweMessage(signedMessage : SignedMessage) : async Bool {
    // In a real implementation, this would verify the Ethereum signature
    // For this demo, we'll just accept any signature and create a delegation
    
    let address = signedMessage.message.address;
    let expiration = Time.now() + 24 * 3600 * 1000 * 1000 * 1000; // 24 hours
    
    // Create a mock delegation
    let delegation : Delegation = {
      pubkey = []; // In a real implementation, this would be derived from the signature
      expiration = expiration;
      targets = null; // Allow delegation to any canister
    };
    
    // Store the identity
    let identity : Identity = {
      address = address;
      expiration = expiration;
      delegations = [delegation];
    };
    
    identities.put(address, identity);
    
    return true;
  };

  // Get the identity for an address
  public query func getIdentity(address : Text) : async ?Identity {
    identities.get(address)
  };

  // Helper function to generate a random nonce
  private func generateNonce() : Text {
    let now = Int.toText(Time.now());
    let rand = Int.toText(Time.now() % 1000000);
    now # "-" # rand
  };
  
  // Update environment configuration
  public shared(msg) func updateEnvironmentConfig(
    newProductionDomain : ?Text,
    newProductionUri : ?Text,
    newDevelopmentDomain : ?Text,
    newDevelopmentUri : ?Text
  ) : async () {
    // In a production environment, you might want to add access control here
    // to ensure only authorized principals can update the configuration
    
    switch (newProductionDomain) {
      case (?domain) { productionDomain := domain };
      case (null) {};
    };
    
    switch (newProductionUri) {
      case (?uri) { productionUri := uri };
      case (null) {};
    };
    
    switch (newDevelopmentDomain) {
      case (?domain) { developmentDomain := domain };
      case (null) {};
    };
    
    switch (newDevelopmentUri) {
      case (?uri) { developmentUri := uri };
      case (null) {};
    };
  };
  
  // Get current environment configuration
  public query func getEnvironmentConfig() : async {
    productionDomain : Text;
    productionUri : Text;
    developmentDomain : Text;
    developmentUri : Text;
  } {
    {
      productionDomain = productionDomain;
      productionUri = productionUri;
      developmentDomain = developmentDomain;
      developmentUri = developmentUri;
    }
  };
}

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
# Various IDEs and editors
.idea/
.vscode/
*.swp
*.swo

# dfx temporary files
.dfx/

# generated files
src/declarations/
dist/

# dependencies
node_modules/

# Rust
target/

# environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# misc
.DS_Store
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.mp4
.mp4

================
File: .ic-assets.json5
================
[
  {
    "match": "**/*",
    "security_policy": "standard"
  }
]

================
File: clean.sh
================
#!/bin/bash

# Clean up script for BitOBytes project

echo "Cleaning up BitOBytes..."

# Stop the dfx replica if it's running
dfx stop

# Remove .dfx directory
rm -rf .dfx

# Clean up frontend build artifacts
cd src/bitobytes_frontend
npm run clean
cd ../..

# Remove dist directory
rm -rf dist

echo "Cleanup complete! You can now run setup.sh to start fresh."

================
File: deploy-rust-siwe.sh
================
#!/bin/bash

# This script deploys the Rust-based SIWE provider canister

# Exit on error
set -e

echo "Deploying Rust-based SIWE provider canister..."

# Check if dfx is installed
if ! command -v dfx &> /dev/null; then
    echo "Error: dfx is not installed. Please install the Internet Computer SDK."
    exit 1
fi

# Check if dfx is running
if ! dfx ping &> /dev/null; then
    echo "Starting local dfx replica..."
    dfx start --background
fi

# Deploy the SIWE provider canister
echo "Creating SIWE provider canister..."
dfx canister create ic_siwe_provider

# Get the canister ID
CANISTER_ID=$(dfx canister id ic_siwe_provider)
echo "SIWE provider canister ID: $CANISTER_ID"

# Update the environment variables
echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env.local
echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env
echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env

echo "Deploying Rust-based SIWE provider canister..."
dfx deploy ic_siwe_provider --argument '(
    record {
        domain = "bitobytes.icp";
        uri = "https://bitobytes.icp";
        salt = "bitobytes-salt-123";
        chain_id = opt 1;
        scheme = opt "https";
        statement = opt "Sign in with Ethereum to BitOBytes on the Internet Computer";
        sign_in_expires_in = opt 3_600_000_000_000;
        session_expires_in = opt 86_400_000_000_000;
        targets = opt vec {
            "'$CANISTER_ID'";
        };
    }
)'

echo "Rust-based SIWE provider canister deployed successfully!"
echo "Canister ID: $CANISTER_ID"
echo "Environment variable set in src/bitobytes_frontend/.env.local"

================
File: deploy-siwe.sh
================
#!/bin/bash

# Script to deploy the SIWE provider with environment-specific configuration

# Determine the environment
if [ "$1" == "production" ]; then
  echo "Deploying SIWE provider for production environment"
  DOMAIN="your-production-domain.icp0.io"  # Replace with your actual production domain
  URI="https://your-production-domain.icp0.io"  # Replace with your actual production URI
  SCHEME="https"
else
  echo "Deploying SIWE provider for local development environment"
  DOMAIN="127.0.0.1"
  URI="http://localhost:3000"  # Using Next.js default port
  SCHEME="http"
fi

# Deploy the SIWE provider
dfx deploy ic_siwe_provider --argument "( \
    record { \
        domain = \"$DOMAIN\"; \
        uri = \"$URI\"; \
        salt = \"salt\"; \
        chain_id = opt 1; \
        scheme = opt \"$SCHEME\"; \
        statement = opt \"Login to the BitOBytes app\"; \
        sign_in_expires_in = opt 300000000000; /* 5 minutes */ \
        session_expires_in = opt 604800000000000; /* 1 week */ \
        targets = opt vec { \
            \"$(dfx canister id ic_siwe_provider)\"; \
            \"$(dfx canister id bitobytes_backend)\"; \
        }; \
    } \
)"

# Generate the declarations
dfx generate ic_siwe_provider

# Update the .env.local file with the canister ID
SIWE_CANISTER_ID=$(dfx canister id ic_siwe_provider)
echo "SIWE provider canister ID: $SIWE_CANISTER_ID"

# Check if .env.local exists
if [ -f "src/bitobytes_frontend/.env.local" ]; then
  # Update the existing file
  sed -i '' "s/NEXT_PUBLIC_SIWE_CANISTER_ID=.*/NEXT_PUBLIC_SIWE_CANISTER_ID=$SIWE_CANISTER_ID/" src/bitobytes_frontend/.env.local
else
  # Create a new file
  echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$SIWE_CANISTER_ID" > src/bitobytes_frontend/.env.local
  
  # Add the IC host based on environment
  if [ "$1" == "production" ]; then
    echo "NEXT_PUBLIC_IC_HOST=https://ic0.app" >> src/bitobytes_frontend/.env.local
  else
    echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env.local
  fi
fi

echo "SIWE provider deployed successfully!"

================
File: deploy.sh
================
#!/bin/bash

# A script to deploy the BitOBytes project

echo "Preparing for deployment..."

# Create necessary directories
mkdir -p dist/bitobytes_frontend

# Build and export the frontend
cd src/bitobytes_frontend
npm run build
# Copy the exported files to the dist directory
mkdir -p ../../dist/bitobytes_frontend
rm -rf ../../dist/bitobytes_frontend/*
cp -r dist/* ../../dist/bitobytes_frontend/
cd ../..

# Deploy to local replica
echo "Deploying to local replica..."
dfx deploy

echo "Deployment complete!"
echo "Visit http://localhost:8000?canisterId=$(dfx canister id bitobytes_frontend) to view your application"

================
File: dfx.json
================
{
  "canisters": {
    "bitobytes_backend": {
      "main": "src/bitobytes_backend/main.mo",
      "type": "motoko"
    },
    "bitobytes_frontend": {
      "dependencies": [
        "bitobytes_backend",
        "ic_siwe_provider"
      ],
      "frontend": {
        "entrypoint": "src/bitobytes_frontend/src/index.html"
      },
      "source": [
        "src/bitobytes_frontend/assets",
        "dist/bitobytes_frontend/"
      ],
      "type": "assets"
    },
    "ic_siwe_provider": {
      "type": "custom",
      "candid": "https://github.com/kristoferlund/ic-siwe/releases/download/v0.1.0/ic_siwe_provider.did",
      "wasm": "https://github.com/kristoferlund/ic-siwe/releases/download/v0.1.0/ic_siwe_provider.wasm.gz"
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "version": 1
}

================
File: FIX-SIWE-STEPS.md
================
# Step-by-Step Guide to Fix SIWE Integration

This guide provides detailed steps to fix the "BLS DER-encoded public key must be 133 bytes long" error in your SIWE (Sign-In With Ethereum) implementation.

## Prerequisites

- Ensure `dfx` CLI is installed and updated to the latest version
- Make sure you have Node.js and npm installed
- Clear browser storage for your local development site

## Step 1: Make Scripts Executable

```bash
# Make all scripts executable
chmod +x make-scripts-executable.sh
./make-scripts-executable.sh
```

## Step 2: Reset the SIWE Environment

```bash
# This stops dfx, clears existing canister data, and redeploys the SIWE provider
./reset-siwe.sh
```

## Step 3: Verify the SIWE Canister is Accessible

```bash
# Test if the SIWE canister is accessible and responding
./test-siwe-canister.sh
```

If this step fails, you might need to manually deploy the SIWE provider:

```bash
dfx deploy ic_siwe_provider
```

## Step 4: Update Frontend Dependencies

```bash
# Navigate to the frontend directory
cd src/bitobytes_frontend

# Update dependencies (optional if reset-siwe.sh already did this)
npm install
```

## Step 5: Start the Development Server

```bash
# In the frontend directory
npm run dev
```

## Step 6: Test Authentication in Browser

1. Open http://localhost:3000 in your browser
2. Open browser DevTools (F12) to monitor for errors
3. Connect your Ethereum wallet
4. Click on "Sign Wallet"
5. Check the console for detailed error messages

## Troubleshooting

If you're still encountering issues:

### Check Environment Variables

Ensure these values are correctly set in `.env` and `.env.local`:

```
NEXT_PUBLIC_SIWE_CANISTER_ID=<your-canister-id>
NEXT_PUBLIC_IC_HOST=http://localhost:4943
```

### Verify API Routing

If API requests are failing, try adding these lines to your browser console:

```javascript
// Enable debug logging
localStorage.setItem('debug', 'ic-siwe-js:*');
```

### Test Direct SIWE Provider Interactions

Try calling the SIWE provider directly from the terminal:

```bash
dfx canister call ic_siwe_provider version
```

### Try with Different Browser/Wallet

Sometimes issues can be browser or wallet-specific. Try using a different browser or wallet to isolate the issue.

## If All Else Fails

As a last resort, you can try a complete reset:

```bash
# Stop dfx
dfx stop

# Remove all .dfx data
rm -rf .dfx

# Remove node_modules
rm -rf src/bitobytes_frontend/node_modules

# Install fresh dependencies
cd src/bitobytes_frontend
npm install

# Start fresh dfx instance
dfx start --clean --background

# Deploy everything
dfx deploy
```

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Luke Foster

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: make-scripts-executable.sh
================
#!/bin/bash

# Make all scripts executable
chmod +x reset-siwe.sh
chmod +x deploy-rust-siwe.sh
chmod +x test-siwe-canister.sh
chmod +x update-dependencies.sh

echo "All scripts are now executable"

================
File: README-SIWE.md
================
# Sign in with Ethereum (SIWE) for BitOBytes

This document provides instructions on how to use the Sign in with Ethereum (SIWE) functionality in the BitOBytes application.

## Overview

BitOBytes now supports authentication using Ethereum wallets through the Sign in with Ethereum (SIWE) protocol. This allows users to sign in using their Ethereum wallet (like MetaMask) instead of traditional username/password authentication.

## Prerequisites

- An Ethereum wallet (MetaMask, WalletConnect, etc.)
- Internet Computer SDK (dfx) installed

## Setup

1. Clone the repository and navigate to the project directory:

```bash
git clone https://github.com/yourusername/BitOBytes.git
cd BitOBytes
```

2. Install dependencies:

```bash
cd src/bitobytes_frontend
npm install
```

3. Deploy the Rust-based SIWE provider canister:

```bash
chmod +x deploy-rust-siwe.sh
./deploy-rust-siwe.sh
```
   This script will:
   - Create the SIWE provider canister
   - Set the necessary environment variables
   - Deploy the canister with the appropriate configuration

4. Start the development server:

```bash
# If dfx is not already running
dfx start --background

# Deploy all canisters
dfx deploy

# Start the Next.js development server
cd src/bitobytes_frontend
npm run dev
```

5. Verify the deployment:
   - Check that the canister ID is correctly set in the environment variables
   - The canister ID should match the output from `dfx canister id ic_siwe_provider`

## Usage

1. Navigate to the application in your browser (usually at http://localhost:3000).
2. Click on "Sign In" in the navigation bar.
3. On the sign-in page, follow these steps:
   - Step 1: Connect your Ethereum wallet by clicking the "Connect Wallet" button.
   - Step 2: Sign in with Ethereum by clicking the "Sign In with Ethereum" button.
   - Your wallet will prompt you to sign a message. This signature is used to authenticate you with the Internet Computer.
4. Once signed in, you can access protected routes like the Profile page.

## Test Signing

The sign-in page also includes a "Test Sign" button that allows you to test your wallet's signing capability without going through the full authentication flow. This is useful for debugging or verifying that your wallet is working correctly.

## Implementation Details

The SIWE functionality is implemented using the following components:

- `ic-siwe-js`: A JavaScript library for integrating SIWE with Internet Computer applications.
- `wagmi`: A React hooks library for Ethereum.
- `viem`: A TypeScript interface for Ethereum.
- `ic_siwe_provider`: A Rust-based canister that handles the SIWE authentication on the Internet Computer.

## Troubleshooting

- If you encounter issues with wallet connection, make sure your wallet is unlocked and connected to the correct network (Ethereum Mainnet or Sepolia Testnet).
- If you see errors related to the SIWE provider canister, make sure it's deployed correctly by running `./deploy-rust-siwe.sh`.
- For other issues, check the browser console for error messages.

## Security Considerations

- The SIWE implementation uses delegated identity, which means your Ethereum private key is never exposed to the application.
- The signed message includes a nonce and expiration time to prevent replay attacks.
- The delegation has a limited lifetime (24 hours by default) after which you'll need to sign in again.
- The Rust-based implementation provides proper cryptographic verification of Ethereum signatures.
- The implementation follows the EIP-4361 (SIWE) standard for secure authentication.

================
File: README.md
================
# BitOBytes

BitOBytes is a decentralized TikTok-like platform built on the Internet Computer Protocol (ICP). This project serves as a simple MVP for a video sharing platform where users can upload, view, and interact with short videos in a decentralized manner.

## Features

- Decentralized video storage (planned integration with Arweave/IPFS)
- User authentication via Internet Identity (coming soon)
- Upload videos with titles and descriptions
- Like videos
- View video feed

## Tech Stack

- **Backend**: Internet Computer Canister developed with Motoko
- **Frontend**: Next.js with TypeScript
- **Styling**: TailwindCSS
- **Authentication**: Internet Identity (upcoming)
- **Storage**: Arweave/IPFS (planned)

## Development Setup

### Prerequisites

- Install the DFINITY SDK (dfx)
- Node.js (v14+) and npm

### Getting Started

1. Clone the repository:
   ```
   git clone https://github.com/yourusername/bitobytes.git
   cd bitobytes
   ```

2. Start the local Internet Computer replica:
   ```
   dfx start --clean --background
   ```

3. Deploy the canisters to the local replica:
   ```
   dfx deploy
   ```

4. Install the frontend dependencies:
   ```
   cd src/bitobytes_frontend
   npm install
   ```

5. Generate the canister interface bindings:
   ```
   dfx generate
   ```

6. Start the Next.js development server:
   ```
   npm run dev
   ```

7. Visit `http://localhost:3000` to see the application.

## Testing the Canister

You can interact with the deployed canister directly using the following commands:

### Add a video
```
dfx canister call bitobytes_backend addVideo '("My Test Video", "https://example.com/video.mp4")'
```

### Get all videos
```
dfx canister call bitobytes_backend getVideos
```

### Like a video
```
dfx canister call bitobytes_backend likeVideo '(0)'
```

## Deployment

To deploy to the Internet Computer mainnet:

```
dfx deploy --network ic
```

## Project Structure

```
bitobytes/
├── .dfx/             # Local state and build artifacts (generated)
├── .gitignore        # Git ignore file
├── dfx.json          # DFX configuration
├── src/              # Source code
│   ├── bitobytes_backend/     # Motoko canister code
│   │   └── main.mo            # Main backend code
│   └── bitobytes_frontend/    # Next.js frontend
│       ├── src/               # Frontend source code
│       ├── package.json       # Frontend dependencies
│       └── ...                # Other Next.js config files
└── README.md         # Project documentation
```

## Next Steps

- [ ] Implement Internet Identity authentication
- [ ] Add video upload functionality with Arweave/IPFS
- [ ] Implement video playback
- [ ] Add comments feature
- [ ] Create user profiles
- [ ] Implement search functionality

================
File: reset-siwe.sh
================
#!/bin/bash

# Exit on error
set -e

echo "Resetting SIWE environment and redeploying canister..."

# Stop any running dfx instances
echo "Stopping any running dfx instances..."
dfx stop || true

# Clear .dfx directory for the SIWE provider
echo "Clearing .dfx directory for SIWE provider..."
rm -rf .dfx/local/canisters/ic_siwe_provider

# Clear browser storage data (instruction for user)
echo "IMPORTANT: Please clear your browser's local storage to remove any cached SIWE data."
echo "In Chrome/Edge: DevTools > Application > Storage > Clear site data"
echo "In Firefox: DevTools > Storage > Local Storage > Right click > Delete All"

# Start dfx
echo "Starting dfx..."
dfx start --clean --background

# Deploy the SIWE provider with proper arguments
echo "Deploying SIWE provider canister..."
./deploy-rust-siwe.sh

echo "SIWE provider deployed successfully!"
echo "Next steps:"
echo "1. Clear your browser's local storage"
echo "2. Navigate to the frontend directory: cd src/bitobytes_frontend"
echo "3. Start the development server: npm run dev"
echo "4. Open your browser at http://localhost:3000"

================
File: setup.sh
================
#!/bin/bash

# A simple script to set up the BitOBytes project

echo "Setting up BitOBytes..."

# Create necessary directories
mkdir -p dist

# Check if dfx is installed
if ! command -v dfx &> /dev/null
then
    echo "dfx could not be found. Please install the DFINITY SDK first:"
    echo "sh -ci \"$(curl -fsSL https://sdk.dfinity.org/install.sh)\""
    exit 1
fi

# Check if Node.js is installed
if ! command -v node &> /dev/null
then
    echo "Node.js could not be found. Please install Node.js (v14+) first."
    exit 1
fi

# Start the local replica if not already running
if ! dfx ping &> /dev/null
then
    echo "Starting the local Internet Computer replica..."
    dfx start --clean --background
fi

# Deploy the canisters
echo "Deploying canisters to the local replica..."
dfx deploy

# Install frontend dependencies
echo "Installing frontend dependencies..."
cd src/bitobytes_frontend
npm install

# Generate canister interface bindings
echo "Generating canister interface bindings..."
cd ../..
dfx generate

echo "Setup complete! To start the frontend development server:"
echo "cd src/bitobytes_frontend && npm run dev"
echo "Then visit: http://localhost:3000"

================
File: SIWE-BLS-FIX.md
================
./# SIWE BLS Error Fix Guide

This document explains the changes made to fix the "BLS DER-encoded public key must be 133 bytes long" error in the BitOBytes project.

## Changes Made

1. **Fixed Server-Side Rendering Issues**
   - Modified `rootKeyFetch.ts` to safely handle server-side rendering
   - Updated `_app.tsx` to conditionally apply the fetch patch only in browser environments
   - Added proper checks for browser-specific objects like `window`

2. **Applied Fetch Patch in _app.tsx**
   - Added `patchFetch()` call to ensure the root key is fetched before any requests to the Internet Computer
   - Enabled debug logging for ic-siwe-js to provide more detailed error information
   - Added fallback for canisterId to ensure it's always a string

3. **Updated Canister ID Handling in declarations/index.js**
   - Removed the hardcoded fallback canister ID to prevent mismatches
   - Added error logging when the canister ID is not set

4. **Enhanced Root Key Fetching in AuthProvider.tsx**
   - Added retry mechanism for root key fetching failures
   - Improved error handling and logging

5. **Improved API Routes**
   - Enhanced error handling for management canister redirects
   - Added better logging for debugging
   - Improved error messages for missing canister IDs

6. **Created Verification Script**
   - Added `verify-siwe-setup.sh` to check and fix common issues with the SIWE setup

## How to Fix the BLS Error

If you're still experiencing the "BLS DER-encoded public key must be 133 bytes long" error, follow these steps:

### Step 1: Run the Verification Script

```bash
./verify-siwe-setup.sh
```

This script will:
- Check if dfx is running
- Verify the SIWE canister exists and is accessible
- Ensure environment variables are correctly set
- Check frontend dependencies

### Step 2: Clear Browser Storage

Clear your browser's local storage to remove any cached SIWE data:
- Chrome/Edge: DevTools > Application > Storage > Clear site data
- Firefox: DevTools > Storage > Local Storage > Right click > Delete All

### Step 3: Restart the Development Server

```bash
cd src/bitobytes_frontend
npm run dev
```

### Step 4: If the Error Persists

If the error still persists, try a complete reset:

```bash
./reset-siwe.sh
```

This will:
- Stop any running dfx instances
- Clear the .dfx directory for the SIWE provider
- Start dfx with a clean state
- Deploy the SIWE provider with proper arguments

## Understanding the BLS Error

The "BLS DER-encoded public key must be 133 bytes long" error occurs when:

1. The root key is not properly fetched for local development
2. There's a mismatch between the canister ID used in the code and the actual canister ID
3. The management canister redirect is not working correctly
4. There are cached delegations in the browser that are no longer valid

The changes made address all these potential causes by:
- Ensuring the root key is fetched before any requests
- Verifying the canister ID is consistent across all files
- Improving the management canister redirect logic
- Providing clear instructions for clearing browser storage

## Debugging Tips

1. Check the browser console for errors
2. Look for "Root key fetched successfully" messages
3. Verify the canister ID being used matches the actual canister ID
4. Check the API route logs for any errors in the management canister redirect

## References

- [SIWE Specification (EIP-4361)](https://eips.ethereum.org/EIPS/eip-4361)
- [ic-siwe-js Documentation](https://github.com/kristoferlund/ic-siwe/tree/main/packages/ic-siwe-js)
- [Internet Computer Documentation](https://internetcomputer.org/docs/current/developer-docs/)

================
File: SIWE-IMPLEMENTATION.md
================
# Sign In With Ethereum (SIWE) Implementation Guide

This document provides instructions on how to use the SIWE authentication in the BitOBytes project.

## Overview

The BitOBytes project uses the Sign In With Ethereum (SIWE) standard to authenticate users. This implementation allows users to connect their Ethereum wallet and sign a message to authenticate with the Internet Computer.

## Local Development

### Setup

1. Make sure you have the Internet Computer SDK (dfx) installed:
   ```bash
   sh -ci "$(curl -fsSL https://internetcomputer.org/install.sh)"
   ```

2. Start the local Internet Computer replica:
   ```bash
   dfx start --clean --background
   ```

3. Deploy the SIWE provider for local development:
   ```bash
   ./deploy-siwe.sh
   ```

4. Deploy the backend canister:
   ```bash
   dfx deploy bitobytes_backend
   ```

5. Start the Next.js development server:
   ```bash
   cd src/bitobytes_frontend
   npm run dev
   ```

6. Open your browser and navigate to http://localhost:3000

### Authentication Flow

1. Click the "Connect" button to connect your Ethereum wallet
2. Once connected, click the "Sign Wallet" button to sign the SIWE message
3. After signing, you'll be authenticated and can access protected resources

## Production Deployment

### Setup

1. Update the production domain in the `deploy-siwe.sh` script:
   ```bash
   DOMAIN="your-production-domain.icp0.io"
   URI="https://your-production-domain.icp0.io"
   ```

2. Deploy the SIWE provider for production:
   ```bash
   ./deploy-siwe.sh production
   ```

3. Deploy the backend canister:
   ```bash
   dfx deploy --network ic bitobytes_backend
   ```

4. Build and deploy the frontend:
   ```bash
   cd src/bitobytes_frontend
   npm run build
   dfx deploy --network ic bitobytes_frontend
   ```

## Environment Variables

The following environment variables are used for the SIWE implementation:

- `NEXT_PUBLIC_SIWE_CANISTER_ID`: The canister ID of the SIWE provider
- `NEXT_PUBLIC_IC_HOST`: The host of the Internet Computer replica (http://localhost:4943 for local development, https://ic0.app for production)

These variables are automatically set by the `deploy-siwe.sh` script.

## Troubleshooting

### Common Issues

1. **"BLS DER-encoded public key must be 133 bytes long" error**:
   - This error occurs when the root key is not properly fetched or when the SIWE provider is not properly configured.
   - Make sure you're running the latest version of dfx.
   - Try restarting the local replica with `dfx start --clean --background`.
   - Redeploy the SIWE provider with `./deploy-siwe.sh`.

2. **"Failed to fetch root key" error**:
   - This error occurs when the API routes can't connect to the Internet Computer replica.
   - Make sure the replica is running with `dfx ping`.
   - Check that the `NEXT_PUBLIC_IC_HOST` environment variable is correctly set.

3. **Authentication fails after signing the message**:
   - Check the browser console for errors.
   - Make sure the SIWE provider is correctly configured with the right domain and URI.
   - Verify that the management canister redirection is working correctly in the API routes.

## References

- [SIWE Specification (EIP-4361)](https://eips.ethereum.org/EIPS/eip-4361)
- [ic-siwe-js Documentation](https://github.com/kristoferlund/ic-siwe/tree/main/packages/ic-siwe-js)
- [Internet Computer Documentation](https://internetcomputer.org/docs/current/developer-docs/)

================
File: SIWE-MIGRATION.md
================
# SIWE Migration: Motoko to Rust Implementation

This document explains the migration from the custom Motoko-based SIWE provider to the official Rust-based implementation.

## Changes Made

1. **Updated dfx.json**
   - Replaced the Motoko-based `ic_siwe_provider` with the pre-built Rust canister
   - The canister now uses the official WASM module and candid interface

2. **Created New Deployment Script**
   - Added `deploy-rust-siwe.sh` for deploying the Rust-based SIWE provider
   - Configured with appropriate settings for BitOBytes

3. **Updated Documentation**
   - Updated README-SIWE.md to reflect the new implementation
   - Added information about the security benefits

## Benefits of the Rust Implementation

### 1. Security Improvements

- **Proper Cryptographic Verification**: Unlike the Motoko placeholder that accepted any signature, the Rust implementation properly verifies Ethereum signatures.
- **Nonce-based Security**: Prevents replay attacks with proper nonce handling.
- **Timebound Sessions**: Configurable expiration for both sign-in messages and sessions.
- **Delegation Targets**: Restricts which canisters can use the delegated identity.

### 2. Compatibility

- **Standard Compliance**: Follows the EIP-4361 (SIWE) standard for secure authentication.
- **Frontend Compatibility**: Works seamlessly with the existing `ic-siwe-js` library.
- **No Frontend Changes Required**: Your existing React components should work without modification.

### 3. Maintainability

- **Production-Ready**: The Rust implementation is production-ready with comprehensive error handling.
- **Well-Documented**: Extensive documentation and examples available.
- **Actively Maintained**: Regular updates and security patches.

## How It Works

The Rust-based SIWE provider follows this authentication flow:

1. **Prepare Login**: Generates a SIWE message with a nonce for the user to sign.
2. **Login**: Verifies the signature and creates a delegation for the session.
3. **Get Delegation**: Provides a signed delegation that can be used for authentication.

## Configuration Options

The Rust-based SIWE provider is configured with these parameters:

- `domain`: The domain from where the frontend is served
- `uri`: The full URI of the frontend
- `salt`: Used for generating unique user principals
- `chain_id`: Ethereum chain ID (default: 1 for mainnet)
- `scheme`: Protocol scheme (http/https)
- `statement`: Message shown to users when signing
- `sign_in_expires_in`: TTL for sign-in messages (nanoseconds)
- `session_expires_in`: TTL for sessions (nanoseconds)
- `targets`: List of canisters allowed for delegation

## Testing the Migration

To test the migration:

1. Deploy the Rust-based SIWE provider:
   ```bash
   ./deploy-rust-siwe.sh
   ```

2. Start the development server:
   ```bash
   dfx start --background
   dfx deploy
   cd src/bitobytes_frontend
   npm run dev
   ```

3. Test the authentication flow by signing in with an Ethereum wallet.

## Troubleshooting

### Canister ID Not Found Error

If you encounter a "canister_id_not_found" error, follow these steps:

1. Make sure you've deployed the Rust-based SIWE provider:
   ```bash
   ./deploy-rust-siwe.sh
   ```

2. Verify that the environment variables are set correctly:
   - Check that `src/bitobytes_frontend/.env` contains the correct canister ID
   - The canister ID should match the output from `dfx canister id ic_siwe_provider`

3. Restart your Next.js development server:
   ```bash
   cd src/bitobytes_frontend
   npm run dev
   ```

4. If the issue persists, try clearing your browser cache or using an incognito window.

### Other Common Issues

- If you encounter issues with the deployment, check the dfx.json configuration.
- If authentication fails after successful deployment, check the browser console for specific error messages.
- For wallet connection issues, make sure your wallet is unlocked and connected to a supported network.

================
File: SIWE-TROUBLESHOOTING.md
================
# SIWE Troubleshooting Guide

This document provides solutions for common issues when implementing Sign-In With Ethereum (SIWE) in your Internet Computer application.

## Common Errors

### "BLS DER-encoded public key must be 133 bytes long"

This error occurs due to incompatibility between the Internet Computer identity libraries and the BLS keys used for delegation. 

**Solution:**

1. Update to the latest `ic-siwe-js` library version:
   ```bash
   npm install ic-siwe-js@latest @dfinity/agent@latest @dfinity/identity@latest
   ```

2. Clear browser storage:
   - Chrome/Edge: DevTools > Application > Storage > Clear site data
   - Firefox: DevTools > Storage > Local Storage > Right click > Delete All

3. Redeployment steps:
   ```bash
   # Stop any running dfx instances
   dfx stop
   
   # Start with a clean state
   dfx start --clean
   
   # Re-deploy the SIWE provider canister
   ./deploy-rust-siwe.sh
   ```

### API Request Errors (400 Bad Request)

If you see errors like `POST http://localhost:3000/api/v2/canister/...` or `/api/v3/canister/...` with 400 Bad Request responses:

**Solution:**

1. Ensure your Next.js rewrites are correctly configured in `next.config.js`
2. Add explicit proxy routes for the specific API endpoints
3. Check that the environment variables are correctly set
4. Verify that the IC replica is running (`dfx ping` should succeed)

### Connection Issues with IC Replica

**Solution:**

1. Ensure the IC replica is running: `dfx ping`
2. Check that `NEXT_PUBLIC_IC_HOST` is set to `http://localhost:4943`
3. Verify the agent is configured with `verifyQuerySignatures: false` for local development

## General Troubleshooting Steps

1. **Reset Environment**:
   ```bash
   ./reset-siwe.sh
   ```

2. **Check Canister Status**:
   ```bash
   dfx canister status ic_siwe_provider
   ```

3. **Test Direct Canister Call**:
   ```bash
   dfx canister call ic_siwe_provider version
   ```

4. **Debug Mode**:
   Enable more verbose logging by setting localStorage:
   ```javascript
   localStorage.setItem('debug', 'ic-siwe-js:*');
   ```

5. **Version Compatibility**:
   Ensure that the versions of `ic-siwe-js` npm package and the `ic_siwe_provider` canister WASM module are compatible.

## Advanced Configuration

For advanced users, you can configure the SIWE provider with custom parameters:

```bash
dfx deploy ic_siwe_provider --argument '(
    record {
        domain = "your-domain.icp";
        uri = "https://your-domain.icp";
        salt = "unique-salt-value";
        chain_id = opt 1;
        scheme = opt "https";
        statement = opt "Custom sign-in message";
        sign_in_expires_in = opt 3_600_000_000_000;
        session_expires_in = opt 86_400_000_000_000;
    }
)'
```

## Still Having Issues?

If you continue to experience problems after trying these solutions:

1. Check the [ic-siwe GitHub repository](https://github.com/kristoferlund/ic-siwe) for recent issues
2. Verify your Ethereum wallet is properly connected and on a supported network
3. Try with a different browser or wallet to isolate the issue

================
File: test-siwe-canister.sh
================
#!/bin/bash

# Get the canister ID from environment variables or from the .env file
CANISTER_ID=$(grep NEXT_PUBLIC_SIWE_CANISTER_ID src/bitobytes_frontend/.env | cut -d '=' -f2)

echo "Testing SIWE canister with ID: $CANISTER_ID"

# Try to call a simple method on the canister
echo "Checking canister status..."
dfx canister status $CANISTER_ID

echo "Trying to call version method..."
dfx canister call $CANISTER_ID version

echo "Testing completed. If you see a version number above, the canister is accessible."

================
File: update-dependencies.sh
================
#!/bin/bash

# Navigate to frontend directory
cd src/bitobytes_frontend

# Update ic-siwe-js to the latest version
npm install ic-siwe-js@latest

# Update related IC libraries to ensure compatibility
npm install @dfinity/agent@latest @dfinity/identity@latest @dfinity/candid@latest

# Clean npm cache
npm cache clean --force

# Reinstall all dependencies to ensure proper resolution
npm install

echo "Dependencies updated successfully!"

================
File: verify-siwe-setup.sh
================
#!/bin/bash

# Exit on error
set -e

echo "===== SIWE Setup Verification Tool ====="
echo "This script will check your SIWE setup and help fix common issues."
echo

# Check if dfx is installed
if ! command -v dfx &> /dev/null; then
    echo "❌ dfx is not installed. Please install the Internet Computer SDK."
    exit 1
fi

# Check if dfx is running
if ! dfx ping &> /dev/null; then
    echo "❌ dfx is not running. Starting local replica..."
    dfx start --background
    sleep 5
else
    echo "✅ dfx is running"
fi

# Check if the SIWE canister exists
if ! dfx canister id ic_siwe_provider &> /dev/null; then
    echo "❌ SIWE provider canister does not exist. Deploying..."
    ./deploy-rust-siwe.sh
else
    echo "✅ SIWE provider canister exists"
    CANISTER_ID=$(dfx canister id ic_siwe_provider)
    echo "   Canister ID: $CANISTER_ID"
fi

# Check if the SIWE canister is accessible
echo "Testing SIWE canister..."
if ! dfx canister call ic_siwe_provider version &> /dev/null; then
    echo "❌ SIWE provider canister is not accessible. Redeploying..."
    ./deploy-rust-siwe.sh
else
    echo "✅ SIWE provider canister is accessible"
    VERSION=$(dfx canister call ic_siwe_provider version)
    echo "   Version: $VERSION"
fi

# Check environment variables
echo "Checking environment variables..."
CANISTER_ID=$(dfx canister id ic_siwe_provider)

# Check .env.local
if [ -f "src/bitobytes_frontend/.env.local" ]; then
    ENV_CANISTER_ID=$(grep NEXT_PUBLIC_SIWE_CANISTER_ID src/bitobytes_frontend/.env.local | cut -d '=' -f2)
    if [ "$ENV_CANISTER_ID" != "$CANISTER_ID" ]; then
        echo "❌ NEXT_PUBLIC_SIWE_CANISTER_ID in .env.local does not match the actual canister ID"
        echo "   Updating .env.local..."
        sed -i '' "s/NEXT_PUBLIC_SIWE_CANISTER_ID=.*/NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID/" src/bitobytes_frontend/.env.local
    else
        echo "✅ NEXT_PUBLIC_SIWE_CANISTER_ID in .env.local is correct"
    fi
    
    if ! grep -q "NEXT_PUBLIC_IC_HOST" src/bitobytes_frontend/.env.local; then
        echo "❌ NEXT_PUBLIC_IC_HOST is not set in .env.local"
        echo "   Adding NEXT_PUBLIC_IC_HOST to .env.local..."
        echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env.local
    else
        echo "✅ NEXT_PUBLIC_IC_HOST is set in .env.local"
    fi
else
    echo "❌ .env.local does not exist. Creating..."
    echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env.local
    echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env.local
fi

# Check .env
if [ -f "src/bitobytes_frontend/.env" ]; then
    ENV_CANISTER_ID=$(grep NEXT_PUBLIC_SIWE_CANISTER_ID src/bitobytes_frontend/.env | cut -d '=' -f2)
    if [ "$ENV_CANISTER_ID" != "$CANISTER_ID" ]; then
        echo "❌ NEXT_PUBLIC_SIWE_CANISTER_ID in .env does not match the actual canister ID"
        echo "   Updating .env..."
        sed -i '' "s/NEXT_PUBLIC_SIWE_CANISTER_ID=.*/NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID/" src/bitobytes_frontend/.env
    else
        echo "✅ NEXT_PUBLIC_SIWE_CANISTER_ID in .env is correct"
    fi
    
    if ! grep -q "NEXT_PUBLIC_IC_HOST" src/bitobytes_frontend/.env; then
        echo "❌ NEXT_PUBLIC_IC_HOST is not set in .env"
        echo "   Adding NEXT_PUBLIC_IC_HOST to .env..."
        echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env
    else
        echo "✅ NEXT_PUBLIC_IC_HOST is set in .env"
    fi
else
    echo "❌ .env does not exist. Creating..."
    echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env
    echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env
fi

# Check if the frontend dependencies are installed
echo "Checking frontend dependencies..."
if [ ! -d "src/bitobytes_frontend/node_modules" ]; then
    echo "❌ Frontend dependencies are not installed. Installing..."
    cd src/bitobytes_frontend
    npm install --legacy-peer-deps
    cd ../..
else
    echo "✅ Frontend dependencies are installed"
fi

# Check for server-side rendering issues
echo "Checking for server-side rendering issues..."
if grep -q "window is not defined" src/bitobytes_frontend/dist/server/pages/_app.js 2>/dev/null; then
    echo "❌ Server-side rendering issue detected: 'window is not defined'"
    echo "   This is likely caused by accessing browser-specific objects in a server context."
    echo "   Please ensure all browser-specific code is wrapped in 'if (typeof window !== 'undefined')' checks."
else
    echo "✅ No obvious server-side rendering issues detected"
fi

echo
echo "===== Verification Complete ====="
echo
echo "If you're still experiencing the 'BLS DER-encoded public key must be 133 bytes long' error:"
echo "1. Clear your browser's local storage:"
echo "   - Chrome/Edge: DevTools > Application > Storage > Clear site data"
echo "   - Firefox: DevTools > Storage > Local Storage > Right click > Delete All"
echo "2. Restart the development server:"
echo "   cd src/bitobytes_frontend && npm run dev"
echo "3. Try logging in again"
echo
echo "If you see 'window is not defined' errors:"
echo "1. Make sure all browser-specific code is wrapped in checks:"
echo "   if (typeof window !== 'undefined') { /* browser-only code */ }"
echo "2. Ensure fetch patching happens only in the browser context"
echo
echo "If the error persists, try a complete reset:"
echo "./reset-siwe.sh"
echo



================================================================
End of Codebase
================================================================
