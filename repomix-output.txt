This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-26T07:33:47.141Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  bitobytes_backend/
    main.mo
  bitobytes_frontend/
    src/
      components/
        login/
          ConnectButton.module.css
          ConnectButton.tsx
          LoginButton.tsx
          LoginPage.tsx
        Navigation.tsx
      context/
        AuthContext.tsx
        AuthProvider.tsx
        index.tsx
      pages/
        api/
          v2/
            canister/
              [canisterId]/
                call.ts
                read_state.ts
            status.ts
          v3/
            canister/
              [canisterId]/
                call.ts
        _app.tsx
        index.tsx
        profile.tsx
        signin.tsx
      styles/
        globals.css
      types/
        next.d.ts
      utils/
        agent.ts
        canisterUtils.ts
        rootKeyFetch.ts
      wagmi/
        is-chain-id-supported.tsx
        wagmi.config.ts
      AuthGuard.tsx
      index.html
    .gitignore
    next.config.js
    package.json
    postcss.config.cjs
    tailwind.config.cjs
    tsconfig.json
  ic_siwe_provider/
    declarations/
      index.js
    main.mo
.gitattributes
.gitignore
.ic-assets.json5
clean.sh
deploy-rust-siwe.sh
deploy-siwe.sh
deploy.sh
dfx.json
FIX-SIWE-STEPS.md
LICENSE
make-scripts-executable.sh
README-SIWE.md
README.md
reset-siwe.sh
setup.sh
SIWE-BLS-FIX.md
SIWE-IMPLEMENTATION.md
SIWE-MIGRATION.md
SIWE-TROUBLESHOOTING.md
test-siwe-canister.sh
update-dependencies.sh
verify-siwe-setup.sh

================================================================
Files
================================================================

================
File: src/bitobytes_backend/main.mo
================
import Time "mo:base/Time";
import Nat "mo:base/Nat";
import Nat64 "mo:base/Nat64";
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Hash "mo:base/Hash";

actor {
  // Video Data Structure
  public type Video = {
    id: Nat64;
    uploader: Principal;
    title: Text;
    mediaRef: Text;
    likes: Nat;
    timestamp: Int;
  };

  // Storage for videos
  private stable var nextId: Nat64 = 0;
  private var videos = HashMap.HashMap<Nat64, Video>(0, Nat64.equal, func(n: Nat64) : Hash.Hash { Hash.hash(Nat64.toNat(n)) });

  // Method to add a new video
  public shared(msg) func addVideo(title: Text, mediaRef: Text) : async Nat64 {
    let videoId = nextId;
    let video: Video = {
      id = videoId;
      uploader = msg.caller;
      title = title;
      mediaRef = mediaRef;
      likes = 0;
      timestamp = Time.now();
    };
    
    videos.put(videoId, video);
    nextId += 1;
    
    return videoId;
  };

  // Method to get all videos
  public query func getVideos() : async [Video] {
    return Iter.toArray(videos.vals());
  };

  // Method to like a video
  public func likeVideo(videoId: Nat64) : async Bool {
    switch (videos.get(videoId)) {
      case (null) {
        return false; // Video not found
      };
      case (?video) {
        let updatedVideo: Video = {
          id = video.id;
          uploader = video.uploader;
          title = video.title;
          mediaRef = video.mediaRef;
          likes = video.likes + 1;
          timestamp = video.timestamp;
        };
        videos.put(videoId, updatedVideo);
        return true;
      };
    }
  };
}

================
File: src/bitobytes_frontend/src/components/login/ConnectButton.module.css
================
.connect-button-container {
  margin-bottom: 1rem;
}

.connect-button {
  background-color: #3b82f6;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.connect-button:hover {
  background-color: #2563eb;
}

.connect-button:disabled {
  background-color: #93c5fd;
  cursor: not-allowed;
}

.wallet-info {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.address-display {
  font-family: monospace;
  padding: 0.25rem 0.5rem;
  background-color: #f3f4f6;
  border-radius: 0.25rem;
  display: inline-block;
}

.disconnect-button {
  background-color: #ef4444;
  color: white;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.875rem;
  cursor: pointer;
  transition: background-color 0.2s;
  width: fit-content;
}

.disconnect-button:hover {
  background-color: #dc2626;
}

.unsupported-chain-warning {
  color: #ef4444;
  font-size: 0.875rem;
  margin-bottom: 0.5rem;
}

.connect-error {
  color: #ef4444;
  font-size: 0.875rem;
  margin-top: 0.5rem;
}

================
File: src/bitobytes_frontend/src/components/login/ConnectButton.tsx
================
import React, { useState, useEffect } from 'react';
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { isChainIdSupported } from '../../wagmi/is-chain-id-supported';

const ConnectButton: React.FC = () => {
  const [isConnecting, setIsConnecting] = useState(false);
  const { address, chainId, isConnected } = useAccount();
  const { connect, connectors, error, isPending: isLoading } = useConnect();
  const { disconnect } = useDisconnect();

  // Log available connectors on component mount
  useEffect(() => {
    console.log('Available connectors:', connectors.map(c => ({ name: c.name, ready: c.ready })));
  }, [connectors]);

  const handleConnect = async () => {
    setIsConnecting(true);
    try {
      // Specifically look for the injected connector (MetaMask)
      const injectedConnector = connectors.find(c => c.name === 'Injected');
      
      if (injectedConnector) {
        console.log('Connecting with MetaMask...');
        await connect({ connector: injectedConnector });
      } else {
        console.error('MetaMask connector not found');
        // Try any available connector as fallback
        const anyConnector = connectors.find(c => c.ready);
        if (anyConnector) {
          console.log('Connecting with fallback connector:', anyConnector.name);
          await connect({ connector: anyConnector });
        } else {
          console.error('No ready connectors found');
        }
      }
    } catch (err) {
      console.error('Connection error:', err);
    } finally {
      setIsConnecting(false);
    }
  };

  const handleDisconnect = () => {
    disconnect();
  };

  // Check if the connected chain is supported
  const isUnsupportedChain = chainId ? !isChainIdSupported(chainId) : false;

  return (
    <div className="w-full">
      {!isConnected ? (
        <button
          onClick={handleConnect}
          disabled={isLoading || isConnecting}
          className="w-full py-3 px-4 bg-white border-2 border-gray-800 hover:bg-gray-100 text-gray-900 font-medium rounded-md text-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading || isConnecting ? 'Connecting...' : 'Connect Wallet'}
        </button>
      ) : (
        <div className="w-full">
          {isUnsupportedChain ? (
            <div className="text-red-600 text-sm font-medium mb-2">
              Unsupported network. Please switch to a supported network.
            </div>
          ) : (
            <div className="font-mono bg-gray-100 p-2 rounded-md text-center mb-2">
              {address?.slice(0, 6)}...{address?.slice(-4)}
            </div>
          )}
          <button 
            onClick={handleDisconnect} 
            className="w-full py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-medium rounded-md text-center transition-colors"
          >
            Disconnect
          </button>
        </div>
      )}
      {error && (
        <div className="mt-2 text-red-600 text-sm">
          {error.message}
        </div>
      )}
    </div>
  );
};

export default ConnectButton;

================
File: src/bitobytes_frontend/src/components/login/LoginButton.tsx
================
import React, { useEffect } from 'react';
import { useAccount, useChainId } from 'wagmi';
import { useSiwe } from 'ic-siwe-js/react';
import { isChainIdSupported } from '../../wagmi/is-chain-id-supported';
import { ensureRootKey } from '../../utils/agent';

const LoginButton: React.FC = () => {
  const { isConnected } = useAccount();
  const chainId = useChainId();
  const { 
    login, 
    isLoggingIn, 
    isPreparingLogin, 
    loginError,
    prepareLoginStatus,
    loginStatus,
    identity,
    delegationChain
  } = useSiwe();

  // Log errors for debugging
  useEffect(() => {
    if (loginError) {
      console.error('Login error:', loginError);
      console.error('Login error stack:', loginError.stack);
    }
  }, [loginError]);

  // Log SIWE state for debugging
  useEffect(() => {
    console.log('SIWE State:', { 
      isConnected, 
      chainId,
      isLoggingIn,
      isPreparingLogin,
      prepareLoginStatus,
      loginStatus,
      hasIdentity: !!identity,
      hasDelegationChain: !!delegationChain
    });
  }, [isConnected, chainId, isLoggingIn, isPreparingLogin, prepareLoginStatus, loginStatus, identity, delegationChain]);

  // Enhanced login function with more logging
  const handleLogin = async () => {
    try {
      console.log('Starting login process...');
      console.log('Current chain ID:', chainId);
      console.log('Is chain supported:', isChainIdSupported(chainId));
      console.log('Is connected:', isConnected);
      console.log('Prepare login status:', prepareLoginStatus);
      console.log('Login status:', loginStatus);
      
      // Ensure root key is fetched before login
      console.log('Ensuring root key is fetched...');
      await ensureRootKey();
      console.log('Root key is ready');
      
      // Call the login function
      console.log('Calling login function...');
      await login();
      console.log('Login function completed');
    } catch (error) {
      console.error('Login function threw an error:', error);
      if (error instanceof Error) {
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
      }
    }
  };

  // Button text based on state
  const text = () => {
    if (isLoggingIn) {
      return "Signing in";
    }
    if (isPreparingLogin) {
      return "Preparing";
    }
    return "Sign Wallet";
  };

  // Determine button state
  const disabled =
    !isChainIdSupported(chainId) ||
    isLoggingIn ||
    !isConnected ||
    isPreparingLogin;

  return (
    <div className="w-full">
      <button
        onClick={handleLogin}
        disabled={disabled}
        className="w-full py-3 px-4 bg-white border-2 border-gray-800 hover:bg-gray-100 text-gray-900 font-medium rounded-md text-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {text()}
      </button>

      {loginError && (
        <div className="mt-2 text-red-600 text-sm">
          Error: {loginError.message}
        </div>
      )}

      {!isChainIdSupported(chainId) && (
        <div className="mt-2 text-yellow-600 text-sm">
          Please switch to a supported network to sign in.
        </div>
      )}
    </div>
  );
};

export default LoginButton;

================
File: src/bitobytes_frontend/src/components/login/LoginPage.tsx
================
import React, { useState, useEffect } from 'react';
import { useAccount, useSignMessage } from 'wagmi';
import ConnectButton from './ConnectButton';
import LoginButton from './LoginButton';

const LoginPage: React.FC = () => {
  const { isConnected, address } = useAccount();
  const { signMessageAsync, isPending, error } = useSignMessage();
  const [testSignResult, setTestSignResult] = useState<string | null>(null);
  const [testSignError, setTestSignError] = useState<string | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<string>('');

  // Update connection status when isConnected changes
  useEffect(() => {
    if (isConnected) {
      setConnectionStatus('Connected to wallet');
    } else {
      setConnectionStatus('');
    }
  }, [isConnected]);

  // Function to test signing a message
  const handleTestSign = async () => {
    if (!isConnected || !address) {
      setTestSignError('Please connect your wallet first');
      return;
    }

    setTestSignResult(null);
    setTestSignError(null);

    try {
      // Create a test message with timestamp to make it unique
      const message = `Test signing with address ${address} at ${new Date().toISOString()}`;
      
      // Sign the message
      const signature = await signMessageAsync({ message });
      
      // Display the result
      setTestSignResult(`Message signed successfully! Signature: ${signature.slice(0, 20)}...`);
    } catch (err) {
      console.error('Test sign error:', err);
      setTestSignError(`Failed to sign message: ${err instanceof Error ? err.message : String(err)}`);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-[70vh] p-4">
      <h1 className="text-3xl font-bold mb-10 text-center">Sign in with Ethereum</h1>
      
      {connectionStatus && (
        <div className="mb-6 text-green-600 font-medium">
          {connectionStatus}
        </div>
      )}
      
      <div className="w-full max-w-md flex flex-col items-center space-y-6">
        {/* Connect Wallet Button - Always visible */}
        <div className="w-full max-w-xs">
          <ConnectButton />
        </div>

        {/* Sign In Button - Always visible but may be disabled */}
        <div className="w-full max-w-xs">
          <LoginButton />
        </div>

        {/* Test Sign Button - Always visible but may be disabled */}
        <div className="w-full max-w-xs">
          <button
            onClick={handleTestSign}
            disabled={!isConnected || isPending}
            className="w-full py-3 px-4 bg-white border-2 border-gray-800 hover:bg-gray-100 text-gray-900 font-medium rounded-md text-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isPending ? 'Signing...' : 'Test Sign'}
          </button>
        </div>
        
        {/* Results and Errors */}
        {testSignResult && (
          <div className="mt-4 p-3 bg-green-100 text-green-800 rounded-md w-full max-w-xs">
            {testSignResult}
          </div>
        )}
        
        {(testSignError || error) && (
          <div className="mt-4 p-3 bg-red-100 text-red-800 rounded-md w-full max-w-xs">
            {testSignError || error?.message}
          </div>
        )}
      </div>
    </div>
  );
};

export default LoginPage;

================
File: src/bitobytes_frontend/src/components/Navigation.tsx
================
import React from 'react';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { useAuth } from '../context/AuthContext';

const Navigation: React.FC = () => {
  const router = useRouter();
  const { isAuthenticated, logout } = useAuth();

  // Check if the current route matches the given path
  const isActive = (path: string) => router.pathname === path;

  return (
    <nav className="bg-gray-800 text-white p-4">
      <div className="container mx-auto flex justify-between items-center">
        <div className="flex items-center">
          <Link href="/" className="text-xl font-bold">
            BitOBytes
          </Link>
          
          <div className="ml-8 flex space-x-4">
            <Link 
              href="/" 
              className={`hover:text-blue-300 ${isActive('/') ? 'text-blue-300' : ''}`}
            >
              Home
            </Link>
            
            {isAuthenticated && (
              <Link 
                href="/profile" 
                className={`hover:text-blue-300 ${isActive('/profile') ? 'text-blue-300' : ''}`}
              >
                Profile
              </Link>
            )}
          </div>
        </div>
        
        <div>
          {isAuthenticated ? (
            <button 
              onClick={() => {
                logout();
                router.push('/');
              }}
              className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded"
            >
              Sign Out
            </button>
          ) : (
            <Link 
              href="/signin" 
              className={`bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded ${isActive('/signin') ? 'bg-blue-700' : ''}`}
            >
              Sign In
            </Link>
          )}
        </div>
      </div>
    </nav>
  );
};

export default Navigation;

================
File: src/bitobytes_frontend/src/context/AuthContext.tsx
================
import { createContext, useContext } from 'react';

// Create a context for the SIWE authentication state
export const AuthContext = createContext<{
  isAuthenticated: boolean;
  isLoading: boolean;
  login: () => Promise<void>;
  logout: () => void;
}>({
  isAuthenticated: false,
  isLoading: true,
  login: async () => {},
  logout: () => {},
});

// Custom hook to use the auth context
export const useAuth = () => useContext(AuthContext);

================
File: src/bitobytes_frontend/src/context/AuthProvider.tsx
================
import React, { ReactNode, useEffect, useState } from 'react';
import { SiweIdentityProvider, useSiwe } from 'ic-siwe-js/react';
import { WagmiProvider } from 'wagmi';
import { config } from '../wagmi/wagmi.config';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AuthContext } from './AuthContext';
import { ensureRootKey } from '../utils/agent';

// Create a query client for React Query
const queryClient = new QueryClient();

// Props for the AuthProvider component
interface AuthProviderProps {
  children: ReactNode;
  canisterId: string;
}

// Internal provider that uses the SIWE hooks
const InternalAuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { 
    identity, 
    login: siweLogin, 
    clear, 
    isInitializing,
    loginStatus,
    prepareLoginStatus,
    isLoginSuccess,
    isLoginError,
    loginError,
    delegationChain
  } = useSiwe();

  // Derived authentication state
  const isAuthenticated = !!identity;
  const isLoading = isInitializing || loginStatus === 'logging-in';

  // Login function that wraps the SIWE login
  const login = async () => {
    try {
      console.log('Starting SIWE login process...');
      console.log('Current login status:', loginStatus);
      console.log('Current prepare login status:', prepareLoginStatus);
      console.log('Has identity:', !!identity);
      console.log('Has delegation chain:', !!delegationChain);
      
      // Call the SIWE login function
      await siweLogin();
      console.log('SIWE login function completed');
    } catch (error) {
      console.error('Login failed:', error);
      if (error instanceof Error) {
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
      }
    }
  };

  // Logout function
  const logout = () => {
    console.log('Logging out...');
    console.log('Current identity:', identity?.getPrincipal().toString());
    clear();
    console.log('Identity cleared');
  };

  // Log authentication state changes
  useEffect(() => {
    console.log('Auth state changed:', {
      isAuthenticated,
      isLoading,
      loginStatus,
      prepareLoginStatus,
      isLoginSuccess,
      isLoginError
    });
    
    if (isLoginSuccess) {
      console.log('Login successful');
      console.log('Identity principal:', identity?.getPrincipal().toString());
      console.log('Delegation chain expiration:', delegationChain?.delegations[0]?.delegation.expiration.toString());
    }
    
    if (isLoginError && loginError) {
      console.error('Login error:', loginError);
      console.error('Login error stack:', loginError.stack);
    }
  }, [isLoginSuccess, isLoginError, loginError, isAuthenticated, isLoading, loginStatus, prepareLoginStatus, identity, delegationChain]);

  return (
    <AuthContext.Provider value={{ isAuthenticated, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

// Main provider component that wraps all the necessary providers
export const AuthProvider: React.FC<AuthProviderProps> = ({ children, canisterId }) => {
  const [isRootKeyFetched, setIsRootKeyFetched] = useState(false);
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  
  // Ensure canisterId is available and log it for debugging
  console.log('SIWE canister ID:', canisterId);
  console.log('IC host:', host);
  
  if (!canisterId) {
    console.warn('No canisterId provided to AuthProvider');
  }

  // Setup localStorage debug option for more detailed logging
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('debug', 'ic-siwe-js:*');
    }
  }, []);

  // Fetch root key for local development
  useEffect(() => {
    const fetchRootKey = async () => {
      if (host.includes('localhost') && !isRootKeyFetched) {
        try {
          console.log('Fetching root key for local development...');
          await ensureRootKey();
          console.log('Root key fetched successfully');
          setIsRootKeyFetched(true);
        } catch (error) {
          console.error('Failed to fetch root key:', error);
          if (error instanceof Error) {
            console.error('Error message:', error.message);
            console.error('Error stack:', error.stack);
            
            // If we fail to fetch the root key, try again after a delay
            setTimeout(() => {
              setIsRootKeyFetched(false); // Reset to trigger another fetch attempt
            }, 2000);
          }
        }
      } else if (!host.includes('localhost')) {
        // For production, we don't need to fetch the root key
        setIsRootKeyFetched(true);
      }
    };

    fetchRootKey();
  }, [host, isRootKeyFetched]);

  // Log when the component mounts and unmounts
  useEffect(() => {
    console.log('AuthProvider mounted');
    return () => {
      console.log('AuthProvider unmounted');
    };
  }, []);

  // Render the providers only when the root key is fetched for local development
  if (host.includes('localhost') && !isRootKeyFetched) {
    return <div>Loading... Fetching root key for local development.</div>;
  }

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <SiweIdentityProvider
          canisterId={canisterId}
          httpAgentOptions={{
            host,
            verifyQuerySignatures: false,
            fetchOptions: {
              credentials: 'omit',
            },
          }}
        >
          <InternalAuthProvider>
            {children}
          </InternalAuthProvider>
        </SiweIdentityProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
};

================
File: src/bitobytes_frontend/src/context/index.tsx
================
import React, { ReactNode, useEffect } from 'react';
import { SiweIdentityProvider, useSiwe } from 'ic-siwe-js/react';
import { WagmiProvider } from 'wagmi';
import { config } from '../wagmi/wagmi.config';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AuthContext, useAuth } from './AuthContext';
import dynamic from 'next/dynamic';

// Re-export the AuthContext and useAuth hook
export { AuthContext, useAuth };

// Props for the AuthProvider component
interface AuthProviderProps {
  children: ReactNode;
  canisterId: string;
}

// Create a client-side only version of the AuthProvider
const ClientAuthProvider = ({ children, canisterId }: AuthProviderProps) => {
  // Create a query client for React Query
  const queryClient = new QueryClient();

  // Internal provider that uses the SIWE hooks
  const InternalAuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const { 
      identity, 
      login: siweLogin, 
      clear, 
      isInitializing,
      loginStatus,
      isLoginSuccess,
      isLoginError,
      loginError
    } = useSiwe();

    // Derived authentication state
    const isAuthenticated = !!identity;
    const isLoading = isInitializing || loginStatus === 'logging-in';

    // Login function that wraps the SIWE login
    const login = async () => {
      try {
        await siweLogin();
      } catch (error) {
        console.error('Login failed:', error);
      }
    };

    // Logout function
    const logout = () => {
      clear();
    };

    // Log authentication state changes
    useEffect(() => {
      if (isLoginSuccess) {
        console.log('Login successful');
      }
      if (isLoginError && loginError) {
        console.error('Login error:', loginError);
      }
    }, [isLoginSuccess, isLoginError, loginError]);

    return (
      <AuthContext.Provider value={{ isAuthenticated, isLoading, login, logout }}>
        {children}
      </AuthContext.Provider>
    );
  };

  // Create a wrapper for SiweIdentityProvider to handle React 18 compatibility
  const SiweWrapper = ({ children }: { children: React.ReactNode }) => {
    const siweElement = SiweIdentityProvider({
      canisterId,
      children,
    });
    
    // Cast the element to ReactNode to satisfy TypeScript
    return siweElement as unknown as React.ReactElement;
  };

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <SiweWrapper>
          <InternalAuthProvider>
            {children}
          </InternalAuthProvider>
        </SiweWrapper>
      </QueryClientProvider>
    </WagmiProvider>
  );
};

// Export a dynamic version of the AuthProvider that only runs on the client
export const AuthProvider = dynamic<AuthProviderProps>(
  () => Promise.resolve(ClientAuthProvider),
  { ssr: false }
);

================
File: src/bitobytes_frontend/src/pages/api/v2/canister/[canisterId]/call.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { canisterId } = req.query;
    
    if (!canisterId || typeof canisterId !== 'string') {
      return res.status(400).json({ error: 'Invalid canister ID' });
    }

    // Log the request details for debugging
    console.log(`[API v2] Processing call request for canister: ${canisterId}`);
    
    // Determine the host based on environment
    const host = process.env.NODE_ENV === 'production'
      ? 'https://ic0.app'
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`[API v2] Using host: ${host}`);
    
    const agent = new HttpAgent({ 
      host,
      verifyQuerySignatures: false,
      fetchOptions: {
        credentials: 'omit',
      },
    });

    // Fetch the root key for local development
    if (host.includes('localhost') || host.includes('127.0.0.1')) {
      try {
        await agent.fetchRootKey();
        console.log('[API v2] Root key fetched successfully');
      } catch (err) {
        console.error('[API v2] Failed to fetch root key:', err);
        return res.status(500).json({ 
          error: 'Failed to fetch root key',
          message: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // Forward the request to the IC
    const url = `${agent.host}/api/v2/canister/${canisterId}/call`;
    console.log(`[API v2] Forwarding request to: ${url}`);
    
    // Check if the canister ID is the management canister
    const siweCanisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;
    if (canisterId === 'ryjl3-tyaaa-aaaaa-aaaba-cai') {
      console.log(`[API v2] Request is for management canister, redirecting to SIWE provider (${siweCanisterId})`);
      if (!siweCanisterId) {
        console.error('[API v2] NEXT_PUBLIC_SIWE_CANISTER_ID is not set! Cannot redirect management canister request.');
        return res.status(500).json({ 
          error: 'SIWE canister ID not configured',
          message: 'The SIWE canister ID is not set in the environment variables. Please run ./deploy-rust-siwe.sh to deploy the SIWE provider.'
        });
      }
      
      console.log(`[API v2] Redirecting to SIWE canister: ${siweCanisterId}`);
      try {
        const redirectUrl = `${agent.host}/api/v2/canister/${siweCanisterId}/call`;
        console.log(`[API v2] Redirect URL: ${redirectUrl}`);
        
        const response = await fetch(redirectUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/cbor',
          },
          body: req.body,
        });
        
        // Log the response status
        console.log(`[API v2] Redirected response status: ${response.status}`);
        
        // Get the response data
        const data = await response.arrayBuffer();
        
        // Set the content type to match the response
        res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
        
        // Send the response
        return res.status(response.status).send(Buffer.from(data));
      } catch (error) {
        console.error('[API v2] Error redirecting to SIWE canister:', error);
        return res.status(500).json({ 
          error: 'Failed to redirect to SIWE canister',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/cbor',
      },
      body: req.body,
    });

    // Log the response status
    console.log(`[API v2] Response status: ${response.status}`);
    
    // If the response is not successful, try to get more details
    if (!response.ok) {
      let errorText = '';
      try {
        errorText = await response.text();
      } catch (e) {
        errorText = 'Could not extract error text';
      }
      console.error(`[API v2] Error response: ${errorText}`);
      return res.status(response.status).json({ 
        error: 'Error from IC replica', 
        status: response.status,
        details: errorText
      });
    }

    // Get the response data
    const data = await response.arrayBuffer();
    
    // Set the content type to match the response
    res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
    
    // Send the response
    res.status(response.status).send(Buffer.from(data));
  } catch (error) {
    console.error('[API v2] Error proxying call request:', error);
    res.status(500).json({ 
      error: 'Failed to proxy call request',
      message: error instanceof Error ? error.message : String(error)
    });
  }
}

================
File: src/bitobytes_frontend/src/pages/api/v2/canister/[canisterId]/read_state.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { canisterId } = req.query;
    
    if (!canisterId || typeof canisterId !== 'string') {
      return res.status(400).json({ error: 'Invalid canister ID' });
    }

    // Log the request details for debugging
    console.log(`[API read_state] Processing request for canister: ${canisterId}`);
    
    // Determine the host based on environment
    const host = process.env.NODE_ENV === 'production'
      ? 'https://ic0.app'
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`[API read_state] Using host: ${host}`);
    
    const agent = new HttpAgent({ 
      host,
      verifyQuerySignatures: false,
      fetchOptions: {
        credentials: 'omit',
      },
    });

    // Fetch the root key for local development
    if (host.includes('localhost') || host.includes('127.0.0.1')) {
      try {
        await agent.fetchRootKey();
        console.log('[API read_state] Root key fetched successfully');
      } catch (err) {
        console.error('[API read_state] Failed to fetch root key:', err);
        return res.status(500).json({ 
          error: 'Failed to fetch root key',
          message: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // Forward the request to the IC
    const url = `${agent.host}/api/v2/canister/${canisterId}/read_state`;
    console.log(`[API read_state] Forwarding request to: ${url}`);
    
    // Check if the canister ID is the management canister
    const siweCanisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;
    if (canisterId === 'ryjl3-tyaaa-aaaaa-aaaba-cai') {
      console.log(`[API read_state] Request is for management canister, redirecting to SIWE provider (${siweCanisterId})`);
      if (!siweCanisterId) {
        console.error('[API read_state] NEXT_PUBLIC_SIWE_CANISTER_ID is not set! Cannot redirect management canister request.');
        return res.status(500).json({ 
          error: 'SIWE canister ID not configured',
          message: 'The SIWE canister ID is not set in the environment variables. Please run ./deploy-rust-siwe.sh to deploy the SIWE provider.'
        });
      }
      
      console.log(`[API read_state] Redirecting to SIWE canister: ${siweCanisterId}`);
      try {
        const redirectUrl = `${agent.host}/api/v2/canister/${siweCanisterId}/read_state`;
        console.log(`[API read_state] Redirect URL: ${redirectUrl}`);
        
        const response = await fetch(redirectUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/cbor',
          },
          body: req.body,
        });
        
        // Log the response status
        console.log(`[API read_state] Redirected response status: ${response.status}`);
        
        // Get the response data
        const data = await response.arrayBuffer();
        
        // Set the content type to match the response
        res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
        
        // Send the response
        return res.status(response.status).send(Buffer.from(data));
      } catch (error) {
        console.error('[API read_state] Error redirecting to SIWE canister:', error);
        return res.status(500).json({ 
          error: 'Failed to redirect to SIWE canister',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/cbor',
      },
      body: req.body,
    });

    // Log the response status
    console.log(`[API read_state] Response status: ${response.status}`);
    
    // If the response is not successful, try to get more details
    if (!response.ok) {
      let errorText = '';
      try {
        errorText = await response.text();
      } catch (e) {
        errorText = 'Could not extract error text';
      }
      console.error(`[API read_state] Error response: ${errorText}`);
      return res.status(response.status).json({ 
        error: 'Error from IC replica', 
        status: response.status,
        details: errorText
      });
    }

    // Get the response data
    const data = await response.arrayBuffer();
    
    // Set the content type to match the response
    res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
    
    // Send the response
    res.status(response.status).send(Buffer.from(data));
  } catch (error) {
    console.error('[API read_state] Error proxying request:', error);
    res.status(500).json({ 
      error: 'Failed to proxy read_state request',
      message: error instanceof Error ? error.message : String(error)
    });
  }
}

================
File: src/bitobytes_frontend/src/pages/api/v2/status.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';
import * as cbor from 'cbor';

// This endpoint is required by the ic-siwe-js library to check the status of the Internet Computer
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    // Create an agent to connect to the local Internet Computer replica
    const agent = new HttpAgent({
      host: process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943',
    });

    // Fetch the root key since we're connecting to a local replica
    if (process.env.DFX_NETWORK !== 'ic') {
      await agent.fetchRootKey();
    }

    // Get the status directly from the agent
    const status = await agent.status();

    // Convert the status to CBOR format
    const cborData = cbor.encode(status);
    
    // Set the content type to application/cbor
    res.setHeader('Content-Type', 'application/cbor');
    res.status(200).send(Buffer.from(cborData));
  } catch (error) {
    console.error('Error fetching IC status:', error);
    res.status(500).json({ error: 'Failed to fetch IC status' });
  }
}

================
File: src/bitobytes_frontend/src/pages/api/v3/canister/[canisterId]/call.ts
================
import type { NextApiRequest, NextApiResponse } from 'next';
import { HttpAgent } from '@dfinity/agent';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { canisterId } = req.query;
    
    if (!canisterId || typeof canisterId !== 'string') {
      return res.status(400).json({ error: 'Invalid canister ID' });
    }

    // Log the request details for debugging
    console.log(`[API v3] Processing call request for canister: ${canisterId}`);
    
    // Determine the host based on environment
    const host = process.env.NODE_ENV === 'production'
      ? 'https://ic0.app'
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`[API v3] Using host: ${host}`);
    
    const agent = new HttpAgent({ 
      host,
      verifyQuerySignatures: false,
      fetchOptions: {
        credentials: 'omit',
      },
    });

    // Fetch the root key for local development
    if (host.includes('localhost') || host.includes('127.0.0.1')) {
      try {
        await agent.fetchRootKey();
        console.log('[API v3] Root key fetched successfully');
      } catch (err) {
        console.error('[API v3] Failed to fetch root key:', err);
        return res.status(500).json({ 
          error: 'Failed to fetch root key',
          message: err instanceof Error ? err.message : String(err)
        });
      }
    }

    // Forward the request to the IC
    const url = `${agent.host}/api/v3/canister/${canisterId}/call`;
    console.log(`[API v3] Forwarding request to: ${url}`);
    
    // Check if the canister ID is the management canister
    const siweCanisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;
    if (canisterId === 'ryjl3-tyaaa-aaaaa-aaaba-cai') {
      console.log(`[API v3] Request is for management canister, redirecting to SIWE provider (${siweCanisterId})`);
      if (!siweCanisterId) {
        console.error('[API v3] NEXT_PUBLIC_SIWE_CANISTER_ID is not set! Cannot redirect management canister request.');
        return res.status(500).json({ 
          error: 'SIWE canister ID not configured',
          message: 'The SIWE canister ID is not set in the environment variables. Please run ./deploy-rust-siwe.sh to deploy the SIWE provider.'
        });
      }
      
      console.log(`[API v3] Redirecting to SIWE canister: ${siweCanisterId}`);
      try {
        const redirectUrl = `${agent.host}/api/v3/canister/${siweCanisterId}/call`;
        console.log(`[API v3] Redirect URL: ${redirectUrl}`);
        
        const response = await fetch(redirectUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/cbor',
          },
          body: req.body,
        });
        
        // Log the response status
        console.log(`[API v3] Redirected response status: ${response.status}`);
        
        // Get the response data
        const data = await response.arrayBuffer();
        
        // Set the content type to match the response
        res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
        
        // Send the response
        return res.status(response.status).send(Buffer.from(data));
      } catch (error) {
        console.error('[API v3] Error redirecting to SIWE canister:', error);
        return res.status(500).json({ 
          error: 'Failed to redirect to SIWE canister',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/cbor',
      },
      body: req.body,
    });

    // Log the response status
    console.log(`[API v3] Response status: ${response.status}`);
    
    // If the response is not successful, try to get more details
    if (!response.ok) {
      let errorText = '';
      try {
        errorText = await response.text();
      } catch (e) {
        errorText = 'Could not extract error text';
      }
      console.error(`[API v3] Error response: ${errorText}`);
      return res.status(response.status).json({ 
        error: 'Error from IC replica', 
        status: response.status,
        details: errorText
      });
    }

    // Get the response data
    const data = await response.arrayBuffer();
    
    // Set the content type to match the response
    res.setHeader('Content-Type', response.headers.get('Content-Type') || 'application/cbor');
    
    // Send the response
    res.status(response.status).send(Buffer.from(data));
  } catch (error) {
    console.error('[API v3] Error proxying call request:', error);
    res.status(500).json({ 
      error: 'Failed to proxy v3 call request',
      message: error instanceof Error ? error.message : String(error)
    });
  }
}

================
File: src/bitobytes_frontend/src/pages/_app.tsx
================
import '@/styles/globals.css';
import type { AppProps } from 'next/app';
import { AuthProvider } from '../context/index';
import { canisterId } from '../../../ic_siwe_provider/declarations/index';
import { patchFetch } from '../utils/rootKeyFetch';

// Configure global settings for ic-js
if (typeof window !== 'undefined') {
  // Set up environment variables in the browser
  window.process = {
    ...window.process,
    env: {
      ...window.process?.env,
      NEXT_PUBLIC_SIWE_CANISTER_ID: process.env.NEXT_PUBLIC_SIWE_CANISTER_ID,
      NEXT_PUBLIC_IC_HOST: process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943',
    }
  };
  
  // Enable debug logging for ic-siwe-js
  localStorage.setItem('debug', 'ic-siwe-js:*');
  
  // Apply the fetch patch to ensure root key is fetched
  // Use setTimeout to ensure this runs after the component is mounted
  setTimeout(() => {
    patchFetch();
  }, 0);
}

export default function App({ Component, pageProps }: AppProps) {
  // Use environment variable directly as fallback to ensure consistency
  const siweCanisterId = canisterId || process.env.NEXT_PUBLIC_SIWE_CANISTER_ID || '';
  
  if (!siweCanisterId) {
    console.error("WARNING: No SIWE canister ID available. Authentication will not work.");
    console.error("Please run ./deploy-rust-siwe.sh to deploy the SIWE provider and set the environment variable.");
  }
  
  return (
    <AuthProvider canisterId={siweCanisterId}>
      <Component {...pageProps} />
    </AuthProvider>
  );
}

================
File: src/bitobytes_frontend/src/pages/index.tsx
================
import { useState, useEffect } from 'react';
import Head from 'next/head';
import { getBackendActor, Video } from '../utils/canisterUtils';
import Navigation from '../components/Navigation';
import { useAuth } from '../context/AuthContext';

export default function Home() {
  const [videos, setVideos] = useState<Video[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { isAuthenticated } = useAuth();

  const fetchVideos = async () => {
    setLoading(true);
    setError(null);

    try {
      const backendActor = await getBackendActor();
      const fetchedVideos = await backendActor.getVideos();
      console.log('Fetched videos:', fetchedVideos);
      setVideos(fetchedVideos);
    } catch (err) {
      console.error('Error fetching videos:', err);
      setError('Failed to fetch videos. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <Head>
        <title>BitOBytes - Decentralized Video Platform</title>
        <meta name="description" content="Decentralized TikTok-like platform on the Internet Computer" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Navigation />

      <div className="container mx-auto px-4">
        <main className="py-8">
          <div className="flex flex-col items-center justify-center mb-8">
            <h1 className="text-3xl font-bold mb-6">BitOBytes</h1>
            
            {isAuthenticated ? (
              <p className="mb-4 text-green-600">You are signed in with Ethereum!</p>
            ) : (
              <p className="mb-4 text-gray-600">Sign in with Ethereum to access all features.</p>
            )}
            
            <button 
              className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded"
              onClick={fetchVideos}
              disabled={loading}
            >
              {loading ? 'Loading...' : 'Fetch Videos'}
            </button>

            {error && (
              <p className="text-red-500 mt-4">{error}</p>
            )}
          </div>

          <div className="video-list">
            <h2 className="text-xl font-semibold mb-4">Videos</h2>
            
            {videos.length === 0 ? (
              <p className="text-gray-500">No videos found. Videos will appear here after fetching.</p>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {videos.map((video) => (
                  <div key={video.id.toString()} className="video-item bg-white shadow-md rounded-lg p-4">
                    <h3 className="text-lg font-medium">{video.title}</h3>
                    <p className="text-sm text-gray-500">
                      ID: {video.id.toString()} | Likes: {video.likes.toString()}
                    </p>
                    <p className="text-sm">Media Reference: {video.mediaRef}</p>
                  </div>
                ))}
              </div>
            )}
          </div>
        </main>

        <footer className="mt-8 pt-8 border-t border-gray-200 text-center text-gray-500">
          <p>Powered by Internet Computer</p>
        </footer>
      </div>
    </div>
  );
}

================
File: src/bitobytes_frontend/src/pages/profile.tsx
================
import React from 'react';
import Head from 'next/head';
import { useAccount } from 'wagmi';
import { useSiwe } from 'ic-siwe-js/react';
import AuthGuard from '../AuthGuard';

export default function Profile() {
  const { address } = useAccount();
  const { identity, identityAddress } = useSiwe();

  return (
    <AuthGuard>
      <div className="container mx-auto px-4 py-8">
        <Head>
          <title>Profile - BitOBytes</title>
          <meta name="description" content="Your BitOBytes profile" />
        </Head>

        <main>
          <h1 className="text-2xl font-bold mb-6">Your Profile</h1>
          
          <div className="bg-white shadow-md rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Ethereum Account</h2>
            
            <div className="mb-4">
              <p className="text-sm text-gray-500 mb-1">Connected Address:</p>
              <p className="font-mono bg-gray-100 p-2 rounded">{address}</p>
            </div>
            
            <div className="mb-4">
              <p className="text-sm text-gray-500 mb-1">Identity Address:</p>
              <p className="font-mono bg-gray-100 p-2 rounded">{identityAddress}</p>
            </div>
            
            <div className="mb-4">
              <p className="text-sm text-gray-500 mb-1">Internet Computer Identity:</p>
              <p className="font-mono bg-gray-100 p-2 rounded overflow-x-auto">
                {identity ? identity.getPrincipal().toString() : 'Not available'}
              </p>
            </div>
          </div>
        </main>
      </div>
    </AuthGuard>
  );
}

================
File: src/bitobytes_frontend/src/pages/signin.tsx
================
import React from 'react';
import Head from 'next/head';
import LoginPage from '../components/login/LoginPage';

export default function SignIn() {
  return (
    <div className="container mx-auto px-4 py-8">
      <Head>
        <title>Sign In - BitOBytes</title>
        <meta name="description" content="Sign in to BitOBytes with Ethereum" />
      </Head>

      <main>
        <LoginPage />
      </main>
    </div>
  );
}

================
File: src/bitobytes_frontend/src/styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 0;
  border-bottom: 1px solid #e5e7eb;
}

.button {
  background-color: #3b82f6;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.button:hover {
  background-color: #2563eb;
}

.video-list {
  margin-top: 2rem;
}

.video-item {
  padding: 1rem;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  margin-bottom: 1rem;
}

================
File: src/bitobytes_frontend/src/types/next.d.ts
================
// Type declarations for Next.js modules
declare module 'next/app' {
  import { AppProps as NextAppProps } from 'next/dist/shared/lib/router/router';
  export type AppProps = NextAppProps;
}

declare module 'next/head' {
  import React from 'react';
  export default function Head(props: React.PropsWithChildren<{}>): JSX.Element;
}

declare module 'next/link' {
  import React from 'react';
  
  export interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
    href: string;
    as?: string;
    replace?: boolean;
    scroll?: boolean;
    shallow?: boolean;
    passHref?: boolean;
    prefetch?: boolean;
  }
  
  export default function Link(props: React.PropsWithChildren<LinkProps>): JSX.Element;
}

declare module 'next/router' {
  export interface RouterProps {
    pathname: string;
    query: Record<string, string | string[]>;
    asPath: string;
    push: (url: string, as?: string, options?: any) => Promise<boolean>;
    replace: (url: string, as?: string, options?: any) => Promise<boolean>;
    reload: () => void;
    back: () => void;
    prefetch: (url: string) => Promise<void>;
    beforePopState: (cb: (state: any) => boolean) => void;
    events: {
      on: (event: string, handler: (...args: any[]) => void) => void;
      off: (event: string, handler: (...args: any[]) => void) => void;
      emit: (event: string, ...args: any[]) => void;
    };
    isFallback: boolean;
    isReady: boolean;
  }
  
  export function useRouter(): RouterProps;
}

================
File: src/bitobytes_frontend/src/utils/agent.ts
================
import { HttpAgent } from '@dfinity/agent';

// Global agent instance
let globalAgent: HttpAgent | null = null;

// Global promise to track root key fetching
let rootKeyPromise: Promise<void> | null = null;

/**
 * Creates a properly configured HttpAgent for interacting with the Internet Computer
 * @param waitForRootKey Whether to wait for the root key to be fetched before returning
 * @returns A configured HttpAgent instance
 */
export async function createAgent(waitForRootKey = true): Promise<HttpAgent> {
  // If we already have a global agent, return it
  if (globalAgent) {
    // If we need to wait for the root key and it's being fetched, wait for it
    if (waitForRootKey && rootKeyPromise) {
      try {
        await rootKeyPromise;
      } catch (err) {
        console.error('Error waiting for root key:', err);
        // If there was an error, we'll create a new agent
        globalAgent = null;
      }
    }
    
    if (globalAgent) {
      return globalAgent;
    }
  }
  
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  console.log('Creating agent with host:', host);
  
  const agent = new HttpAgent({
    host,
    // Disable verification for local development
    verifyQuerySignatures: false,
    // Ensure fetches complete without credentials for CORS
    fetchOptions: {
      credentials: 'omit',
    },
  });
  
  // In a local development environment, we need to fetch the root key for verification
  if (host.includes('localhost') || host.includes('127.0.0.1')) {
    if (!rootKeyPromise) {
      // Create the promise only once
      rootKeyPromise = (async () => {
        try {
          console.log('Fetching root key...');
          // Add a custom header to identify this as a root key fetch to prevent infinite recursion
          await agent.fetchRootKey();
          console.log('Root key fetched successfully');
        } catch (err) {
          console.error('Failed to fetch root key:', err);
          // Reset the promise so we can try again
          rootKeyPromise = null;
          throw err;
        }
      })();
    }
    
    if (waitForRootKey) {
      try {
        // Wait for the root key to be fetched
        await rootKeyPromise;
        // Store the agent globally only after the root key is fetched
        globalAgent = agent;
      } catch (err) {
        console.error('Error waiting for root key:', err);
        throw err;
      }
    } else {
      // Store the agent globally even if we don't wait for the root key
      globalAgent = agent;
    }
  } else {
    // For production, store the agent globally
    globalAgent = agent;
  }
  
  return agent;
}

/**
 * Gets the global agent, creating it if necessary
 * @param waitForRootKey Whether to wait for the root key to be fetched before returning
 * @returns The global HttpAgent instance
 */
export async function getAgent(waitForRootKey = true): Promise<HttpAgent> {
  if (!globalAgent) {
    return createAgent(waitForRootKey);
  }
  
  return globalAgent;
}

/**
 * Ensures the root key is fetched for local development
 * @returns A promise that resolves when the root key is fetched
 */
export async function ensureRootKey(): Promise<void> {
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  
  if (host.includes('localhost') || host.includes('127.0.0.1')) {
    // This will create the agent and wait for the root key
    await createAgent(true);
  }
}

/**
 * Resets the global agent, forcing a new one to be created next time
 */
export function resetAgent(): void {
  globalAgent = null;
  rootKeyPromise = null;
}

================
File: src/bitobytes_frontend/src/utils/canisterUtils.ts
================
import { Actor, HttpAgent } from '@dfinity/agent';
import { Principal } from '@dfinity/principal';

// When deploying locally, we'll need to create this manually after "dfx generate"
// For now, we'll define the interface for TypeScript
export interface Video {
  id: bigint;
  uploader: Principal;
  title: string;
  mediaRef: string;
  likes: bigint;
  timestamp: bigint;
}

export interface BitobytesBackend {
  addVideo: (title: string, mediaRef: string) => Promise<bigint>;
  getVideos: () => Promise<Video[]>;
  likeVideo: (videoId: bigint) => Promise<boolean>;
}

// Will be filled in by dfx generate after deployment
let canisterId: string;
let actor: BitobytesBackend;

export const initializeCanister = async () => {
  // When deploying locally
  const isLocalEnv = process.env.NODE_ENV !== 'production';
  
  try {
    const host = isLocalEnv ? 'http://localhost:4943' : 'https://ic0.app';
    const agent = new HttpAgent({ host });
    
    // When running locally, we need to fetch the root key
    if (isLocalEnv) {
      await agent.fetchRootKey();
    }

    // Use the correct canister ID from deployment
    canisterId = isLocalEnv ? 'bkyz2-fmaaa-aaaaa-qaaaq-cai' : 'YOUR_PRODUCTION_CANISTER_ID';
    
    // Once we have generated declarations, we'll replace this with properly typed Actor
    actor = Actor.createActor<BitobytesBackend>(
      // This will be filled in by the generated declarations
      ({ IDL }) => {
        const Video = IDL.Record({
          'id': IDL.Nat64,
          'uploader': IDL.Principal,
          'title': IDL.Text,
          'mediaRef': IDL.Text,
          'likes': IDL.Nat,
          'timestamp': IDL.Int,
        });
        return IDL.Service({
          'addVideo': IDL.Func([IDL.Text, IDL.Text], [IDL.Nat64], []),
          'getVideos': IDL.Func([], [IDL.Vec(Video)], ['query']),
          'likeVideo': IDL.Func([IDL.Nat64], [IDL.Bool], []),
        });
      },
      { agent, canisterId }
    );
    
    return actor;
  } catch (error) {
    console.error('Error initializing canister:', error);
    throw error;
  }
};

export const getBackendActor = async (): Promise<BitobytesBackend> => {
  if (!actor) {
    await initializeCanister();
  }
  return actor;
};

================
File: src/bitobytes_frontend/src/utils/rootKeyFetch.ts
================
import { HttpAgent } from '@dfinity/agent';

// Store the original fetch function
let originalFetch: typeof fetch | null = null;

// Flag to track if the root key has been fetched
let rootKeyFetched = false;

// Promise to track the root key fetching process
let rootKeyPromise: Promise<void> | null = null;

// Check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Initialize originalFetch in browser environment
if (isBrowser) {
  originalFetch = window.fetch;
}

/**
 * Ensures the root key is fetched for local development
 * @returns A promise that resolves when the root key is fetched
 */
export async function ensureRootKey(): Promise<void> {
  const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
  
  // Only fetch the root key for local development
  if (!host.includes('localhost') && !host.includes('127.0.0.1')) {
    return;
  }
  
  // If the root key has already been fetched, return immediately
  if (rootKeyFetched) {
    return;
  }
  
  // If there's an existing promise, wait for it
  if (rootKeyPromise) {
    await rootKeyPromise;
    return;
  }
  
  // Create a new promise to fetch the root key
  rootKeyPromise = (async () => {
    try {
      console.log('Fetching root key for local development...');
      const agent = new HttpAgent({
        host,
        fetchOptions: { credentials: 'omit' }
      });
      await agent.fetchRootKey();
      console.log('Root key fetched successfully');
      rootKeyFetched = true;
    } catch (error) {
      console.error('Failed to fetch root key:', error);
      // Reset the promise so we can try again
      rootKeyPromise = null;
      throw error;
    }
  })();
  
  await rootKeyPromise;
}

// Flag to track if we're currently inside a fetch for the root key
let fetchingRootKey = false;

/**
 * Patches the global fetch function to ensure the root key is fetched before
 * making requests to the Internet Computer
 */
export function patchFetch(): void {
  // Only patch in the browser environment
  if (typeof window === 'undefined') {
    return;
  }
  
  // Only patch once
  if (window.fetch !== originalFetch) {
    return;
  }
  
  // Replace the global fetch function with our patched version
  window.fetch = async function patchedFetch(input, init) {
    // Check if this is a request to the Internet Computer
    const url = input instanceof Request ? input.url : String(input);
    const host = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    // If this is a request to the local Internet Computer and we're not already fetching the root key,
    // ensure the root key is fetched
    if (!fetchingRootKey && 
        (url.includes(host) || url.includes('/api/v2/') || url.includes('/api/v3/')) && 
        (host.includes('localhost') || host.includes('127.0.0.1'))) {
      
      // If the URL contains "fetch_root_key", we're fetching the root key
      if (url.includes('fetch_root_key')) {
        fetchingRootKey = true;
      } else {
        try {
          // Only try to ensure root key if we're not already fetching it
          if (rootKeyFetched === false && rootKeyPromise === null) {
            await ensureRootKey();
          } else if (rootKeyPromise) {
            await rootKeyPromise;
          }
        } catch (error) {
          console.error('Failed to fetch root key before request:', error);
          // Continue with the request even if root key fetching fails
        }
      }
    }
    
    // Call the original fetch function
    if (!originalFetch) {
      console.error('Original fetch function is not available');
      return window.fetch(input, init);
    }
    
    try {
      return await originalFetch.call(window, input, init);
    } finally {
      // Reset the flag after the fetch is complete
      if (fetchingRootKey && url.includes('fetch_root_key')) {
        fetchingRootKey = false;
      }
    }
  };
  
  console.log('Patched fetch function to ensure root key is fetched');
}

/**
 * Restores the original fetch function
 */
export function restoreFetch(): void {
  if (typeof window !== 'undefined' && window.fetch !== originalFetch && originalFetch !== null) {
    window.fetch = originalFetch;
    console.log('Restored original fetch function');
  }
}

================
File: src/bitobytes_frontend/src/wagmi/is-chain-id-supported.tsx
================
import { wagmiChains } from './wagmi.config';

/**
 * Checks if a given chain ID is supported by the application
 * @param chainId The chain ID to check
 * @returns boolean indicating if the chain is supported
 */
export function isChainIdSupported(chainId: number): boolean {
  return wagmiChains.some((chain) => chain.id === chainId);
}

================
File: src/bitobytes_frontend/src/wagmi/wagmi.config.ts
================
import { createConfig, http } from 'wagmi';
import { mainnet, sepolia } from 'wagmi/chains';
import { injected, walletConnect } from 'wagmi/connectors';

// Create wagmi config with supported chains and connectors
export const config = createConfig({
  chains: [mainnet, sepolia],
  connectors: [
    injected({
      shimDisconnect: true, // This helps with MetaMask disconnect issues
    }),
    walletConnect({
      // Using the provided projectId
      // In production, you should use an environment variable
      projectId: '3314f21eac8f71b9c7d0fd4b2ab0db7c',
    }),
  ],
  transports: {
    [mainnet.id]: http(),
    [sepolia.id]: http(),
  },
});

// Export the configured chains for use in other components
export const wagmiChains = [mainnet, sepolia];

================
File: src/bitobytes_frontend/src/AuthGuard.tsx
================
import React, { useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from './context/AuthContext';

interface AuthGuardProps {
  children: React.ReactNode;
}

/**
 * AuthGuard component to protect routes that require authentication
 * Redirects to signin page if user is not authenticated
 */
const AuthGuard: React.FC<AuthGuardProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    // If authentication is still loading, do nothing
    if (isLoading) return;

    // If not authenticated and not already on the signin page, redirect to signin
    if (!isAuthenticated && router.pathname !== '/signin') {
      router.push('/signin');
    }
  }, [isAuthenticated, isLoading, router]);

  // Show loading state while checking authentication
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-screen">
        <div className="text-center">
          <div className="spinner mb-4"></div>
          <p>Loading authentication...</p>
        </div>
      </div>
    );
  }

  // If not authenticated, don't render children
  if (!isAuthenticated) {
    return null;
  }

  // If authenticated, render children
  return <>{children}</>;
};

export default AuthGuard;

================
File: src/bitobytes_frontend/src/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BitOBytes - Decentralized Video Platform</title>
  <meta name="description" content="Decentralized TikTok-like platform on the Internet Computer" />
  <link rel="icon" href="/favicon.ico" />
</head>
<body>
  <div id="root"></div>
</body>
</html>

================
File: src/bitobytes_frontend/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
package-lock.json

================
File: src/bitobytes_frontend/next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  // For local development, use local dist
  distDir: 'dist',
  // Comment out static export for development to enable API routes
  // output: 'export',
  images: {
    unoptimized: true,
  },
  // Used for static HTML exports for IC deployment
  trailingSlash: true,
  // Add rewrites for direct API access to the IC replica
  async rewrites() {
    // Determine the host based on environment
    const icHost = process.env.NODE_ENV === 'production' 
      ? 'https://ic0.app' 
      : process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';
    
    console.log(`Using IC host for rewrites: ${icHost}`);
    
    return [
      {
        source: '/api/:path*',
        destination: `${icHost}/api/:path*`,
      },
      // Add more specific rewrites with higher priority
      {
        source: '/api/v2/status',
        destination: `${icHost}/api/v2/status`,
      },
      {
        source: '/api/v2/canister/:canisterId/read_state',
        destination: `${icHost}/api/v2/canister/:canisterId/read_state`,
      },
      {
        source: '/api/v3/canister/:canisterId/call',
        destination: `${icHost}/api/v3/canister/:canisterId/call`,
      },
      // Special handling for the management canister
      {
        source: '/api/v2/canister/ryjl3-tyaaa-aaaaa-aaaba-cai/:path*',
        destination: `${icHost}/api/v2/canister/${process.env.NEXT_PUBLIC_SIWE_CANISTER_ID}/:path*`,
      },
    ];
  },
}

export default nextConfig

================
File: src/bitobytes_frontend/package.json
================
{
  "name": "bitobytes_frontend",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "export": "next build && rm -rf ../../dist/bitobytes_frontend/* && cp -r dist/* ../../dist/bitobytes_frontend/",
    "generate": "dfx generate",
    "clean": "rm -rf .next dist node_modules"
  },
  "dependencies": {
    "@dfinity/agent": "^2.3.0",
    "@dfinity/auth-client": "^2.3.0",
    "@dfinity/candid": "^2.3.0",
    "@dfinity/identity": "^2.3.0",
    "@dfinity/principal": "^2.3.0",
    "@tanstack/react-query": "^5.66.9",
    "@types/next": "^8.0.7",
    "@wagmi/connectors": "^5.7.8",
    "@wagmi/core": "^2.16.5",
    "@web3modal/ethereum": "^2.7.1",
    "@web3modal/wagmi": "^5.1.11",
    "cbor": "^10.0.3",
    "ic-siwe-js": "^0.2.4",
    "next": "^13.4.19",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "viem": "^2.23.5",
    "wagmi": "^2.14.12"
  },
  "devDependencies": {
    "@types/node": "^20.5.6",
    "@types/react": "^18.2.21",
    "@types/react-dom": "^18.2.7",
    "autoprefixer": "^10.4.15",
    "eslint": "^8.48.0",
    "eslint-config-next": "^13.4.19",
    "postcss": "^8.4.28",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.2.2"
  }
}

================
File: src/bitobytes_frontend/postcss.config.cjs
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: src/bitobytes_frontend/tailwind.config.cjs
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: src/bitobytes_frontend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "src/types/**/*.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

================
File: src/ic_siwe_provider/declarations/index.js
================
// This file contains the canister ID for the SIWE provider
// In a production environment, this would be the actual canister ID
// For local development, we'll use the environment variable set by deploy-rust-siwe.sh

// Use the environment variable if available, otherwise use a placeholder
// Note: The placeholder will not work until the canister is deployed
export const canisterId = process.env.NEXT_PUBLIC_SIWE_CANISTER_ID;

// Log the canister ID for debugging
if (!canisterId) {
  console.error("WARNING: NEXT_PUBLIC_SIWE_CANISTER_ID is not set!");
  console.error("Please run ./deploy-rust-siwe.sh to deploy the SIWE provider and set the environment variable.");
} else {
  console.log("SIWE Provider Canister ID:", canisterId);
}

================
File: src/ic_siwe_provider/main.mo
================
import Principal "mo:base/Principal";
import Text "mo:base/Text";
import Time "mo:base/Time";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Array "mo:base/Array";
import Option "mo:base/Option";
import Debug "mo:base/Debug";
import Nat "mo:base/Nat";
import Nat64 "mo:base/Nat64";
import Hash "mo:base/Hash";
import Error "mo:base/Error";
import Int "mo:base/Int";

actor SiweProvider {
  // Type definitions
  public type SiweMessage = {
    domain : Text;
    address : Text;
    statement : Text;
    uri : Text;
    version : Text;
    chainId : Nat;
    nonce : Text;
    issuedAt : Text;
    expirationTime : ?Text;
    notBefore : ?Text;
    requestId : ?Text;
    resources : [Text];
  };

  public type SignedMessage = {
    message : SiweMessage;
    signature : Text;
  };

  public type Identity = {
    address : Text;
    expiration : Int;
    delegations : [Delegation];
  };

  public type Delegation = {
    pubkey : [Nat8];
    expiration : Int;
    targets : ?[Principal];
  };

  // Storage for identities
  private stable var identitiesEntries : [(Text, Identity)] = [];
  private var identities = HashMap.HashMap<Text, Identity>(0, Text.equal, Text.hash);

  // Initialize from stable storage
  system func preupgrade() {
    identitiesEntries := Iter.toArray(identities.entries());
  };

  system func postupgrade() {
    identities := HashMap.fromIter<Text, Identity>(identitiesEntries.vals(), 10, Text.equal, Text.hash);
    identitiesEntries := [];
  };

  // Generate a SIWE message for the given address
  public func generateSiweMessage(address : Text) : async SiweMessage {
    let nonce = generateNonce();
    let currentTime = Time.now();
    let issuedAt = Int.toText(currentTime);
    
    // Create a SIWE message
    let message : SiweMessage = {
      domain = "bitobytes.icp";
      address = address;
      statement = "Sign in with Ethereum to BitOBytes on the Internet Computer";
      uri = "https://bitobytes.icp";
      version = "1";
      chainId = 1; // Ethereum mainnet
      nonce = nonce;
      issuedAt = issuedAt;
      expirationTime = ?Int.toText(currentTime + 3600 * 1000 * 1000 * 1000); // 1 hour expiration
      notBefore = null;
      requestId = null;
      resources = [];
    };
    
    return message;
  };

  // Verify a signed message and create a delegation
  public shared(msg) func verifySiweMessage(signedMessage : SignedMessage) : async Bool {
    // In a real implementation, this would verify the Ethereum signature
    // For this demo, we'll just accept any signature and create a delegation
    
    let address = signedMessage.message.address;
    let expiration = Time.now() + 24 * 3600 * 1000 * 1000 * 1000; // 24 hours
    
    // Create a mock delegation
    let delegation : Delegation = {
      pubkey = []; // In a real implementation, this would be derived from the signature
      expiration = expiration;
      targets = null; // Allow delegation to any canister
    };
    
    // Store the identity
    let identity : Identity = {
      address = address;
      expiration = expiration;
      delegations = [delegation];
    };
    
    identities.put(address, identity);
    
    return true;
  };

  // Get the identity for an address
  public query func getIdentity(address : Text) : async ?Identity {
    identities.get(address)
  };

  // Helper function to generate a random nonce
  private func generateNonce() : Text {
    let now = Int.toText(Time.now());
    let rand = Int.toText(Time.now() % 1000000);
    now # "-" # rand
  };
}

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
# Various IDEs and editors
.idea/
.vscode/
*.swp
*.swo

# dfx temporary files
.dfx/

# generated files
src/declarations/
dist/

# dependencies
node_modules/

# Rust
target/

# environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# misc
.DS_Store
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

================
File: .ic-assets.json5
================
[
  {
    "match": "**/*",
    "security_policy": "standard"
  }
]

================
File: clean.sh
================
#!/bin/bash

# Clean up script for BitOBytes project

echo "Cleaning up BitOBytes..."

# Stop the dfx replica if it's running
dfx stop

# Remove .dfx directory
rm -rf .dfx

# Clean up frontend build artifacts
cd src/bitobytes_frontend
npm run clean
cd ../..

# Remove dist directory
rm -rf dist

echo "Cleanup complete! You can now run setup.sh to start fresh."

================
File: deploy-rust-siwe.sh
================
#!/bin/bash

# This script deploys the Rust-based SIWE provider canister

# Exit on error
set -e

echo "Deploying Rust-based SIWE provider canister..."

# Check if dfx is installed
if ! command -v dfx &> /dev/null; then
    echo "Error: dfx is not installed. Please install the Internet Computer SDK."
    exit 1
fi

# Check if dfx is running
if ! dfx ping &> /dev/null; then
    echo "Starting local dfx replica..."
    dfx start --background
fi

# Deploy the SIWE provider canister
echo "Creating SIWE provider canister..."
dfx canister create ic_siwe_provider

# Get the canister ID
CANISTER_ID=$(dfx canister id ic_siwe_provider)
echo "SIWE provider canister ID: $CANISTER_ID"

# Update the environment variables
echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env.local
echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env
echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env

echo "Deploying Rust-based SIWE provider canister..."
dfx deploy ic_siwe_provider --argument '(
    record {
        domain = "bitobytes.icp";
        uri = "https://bitobytes.icp";
        salt = "bitobytes-salt-123";
        chain_id = opt 1;
        scheme = opt "https";
        statement = opt "Sign in with Ethereum to BitOBytes on the Internet Computer";
        sign_in_expires_in = opt 3_600_000_000_000;
        session_expires_in = opt 86_400_000_000_000;
        targets = opt vec {
            "'$CANISTER_ID'";
        };
    }
)'

echo "Rust-based SIWE provider canister deployed successfully!"
echo "Canister ID: $CANISTER_ID"
echo "Environment variable set in src/bitobytes_frontend/.env.local"

================
File: deploy-siwe.sh
================
#!/bin/bash

# Script to deploy the SIWE provider with environment-specific configuration

# Determine the environment
if [ "$1" == "production" ]; then
  echo "Deploying SIWE provider for production environment"
  DOMAIN="your-production-domain.icp0.io"  # Replace with your actual production domain
  URI="https://your-production-domain.icp0.io"  # Replace with your actual production URI
  SCHEME="https"
else
  echo "Deploying SIWE provider for local development environment"
  DOMAIN="127.0.0.1"
  URI="http://localhost:3000"  # Using Next.js default port
  SCHEME="http"
fi

# Deploy the SIWE provider
dfx deploy ic_siwe_provider --argument "( \
    record { \
        domain = \"$DOMAIN\"; \
        uri = \"$URI\"; \
        salt = \"salt\"; \
        chain_id = opt 1; \
        scheme = opt \"$SCHEME\"; \
        statement = opt \"Login to the BitOBytes app\"; \
        sign_in_expires_in = opt 300000000000; /* 5 minutes */ \
        session_expires_in = opt 604800000000000; /* 1 week */ \
        targets = opt vec { \
            \"$(dfx canister id ic_siwe_provider)\"; \
            \"$(dfx canister id bitobytes_backend)\"; \
        }; \
    } \
)"

# Generate the declarations
dfx generate ic_siwe_provider

# Update the .env.local file with the canister ID
SIWE_CANISTER_ID=$(dfx canister id ic_siwe_provider)
echo "SIWE provider canister ID: $SIWE_CANISTER_ID"

# Check if .env.local exists
if [ -f "src/bitobytes_frontend/.env.local" ]; then
  # Update the existing file
  sed -i '' "s/NEXT_PUBLIC_SIWE_CANISTER_ID=.*/NEXT_PUBLIC_SIWE_CANISTER_ID=$SIWE_CANISTER_ID/" src/bitobytes_frontend/.env.local
else
  # Create a new file
  echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$SIWE_CANISTER_ID" > src/bitobytes_frontend/.env.local
  
  # Add the IC host based on environment
  if [ "$1" == "production" ]; then
    echo "NEXT_PUBLIC_IC_HOST=https://ic0.app" >> src/bitobytes_frontend/.env.local
  else
    echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env.local
  fi
fi

echo "SIWE provider deployed successfully!"

================
File: deploy.sh
================
#!/bin/bash

# A script to deploy the BitOBytes project

echo "Preparing for deployment..."

# Create necessary directories
mkdir -p dist/bitobytes_frontend

# Build and export the frontend
cd src/bitobytes_frontend
npm run build
# Copy the exported files to the dist directory
mkdir -p ../../dist/bitobytes_frontend
rm -rf ../../dist/bitobytes_frontend/*
cp -r dist/* ../../dist/bitobytes_frontend/
cd ../..

# Deploy to local replica
echo "Deploying to local replica..."
dfx deploy

echo "Deployment complete!"
echo "Visit http://localhost:8000?canisterId=$(dfx canister id bitobytes_frontend) to view your application"

================
File: dfx.json
================
{
  "canisters": {
    "bitobytes_backend": {
      "main": "src/bitobytes_backend/main.mo",
      "type": "motoko"
    },
    "bitobytes_frontend": {
      "dependencies": [
        "bitobytes_backend",
        "ic_siwe_provider"
      ],
      "frontend": {
        "entrypoint": "src/bitobytes_frontend/src/index.html"
      },
      "source": [
        "src/bitobytes_frontend/assets",
        "dist/bitobytes_frontend/"
      ],
      "type": "assets"
    },
    "ic_siwe_provider": {
      "type": "custom",
      "candid": "https://github.com/kristoferlund/ic-siwe/releases/download/v0.1.0/ic_siwe_provider.did",
      "wasm": "https://github.com/kristoferlund/ic-siwe/releases/download/v0.1.0/ic_siwe_provider.wasm.gz"
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "version": 1
}

================
File: FIX-SIWE-STEPS.md
================
# Step-by-Step Guide to Fix SIWE Integration

This guide provides detailed steps to fix the "BLS DER-encoded public key must be 133 bytes long" error in your SIWE (Sign-In With Ethereum) implementation.

## Prerequisites

- Ensure `dfx` CLI is installed and updated to the latest version
- Make sure you have Node.js and npm installed
- Clear browser storage for your local development site

## Step 1: Make Scripts Executable

```bash
# Make all scripts executable
chmod +x make-scripts-executable.sh
./make-scripts-executable.sh
```

## Step 2: Reset the SIWE Environment

```bash
# This stops dfx, clears existing canister data, and redeploys the SIWE provider
./reset-siwe.sh
```

## Step 3: Verify the SIWE Canister is Accessible

```bash
# Test if the SIWE canister is accessible and responding
./test-siwe-canister.sh
```

If this step fails, you might need to manually deploy the SIWE provider:

```bash
dfx deploy ic_siwe_provider
```

## Step 4: Update Frontend Dependencies

```bash
# Navigate to the frontend directory
cd src/bitobytes_frontend

# Update dependencies (optional if reset-siwe.sh already did this)
npm install
```

## Step 5: Start the Development Server

```bash
# In the frontend directory
npm run dev
```

## Step 6: Test Authentication in Browser

1. Open http://localhost:3000 in your browser
2. Open browser DevTools (F12) to monitor for errors
3. Connect your Ethereum wallet
4. Click on "Sign Wallet"
5. Check the console for detailed error messages

## Troubleshooting

If you're still encountering issues:

### Check Environment Variables

Ensure these values are correctly set in `.env` and `.env.local`:

```
NEXT_PUBLIC_SIWE_CANISTER_ID=<your-canister-id>
NEXT_PUBLIC_IC_HOST=http://localhost:4943
```

### Verify API Routing

If API requests are failing, try adding these lines to your browser console:

```javascript
// Enable debug logging
localStorage.setItem('debug', 'ic-siwe-js:*');
```

### Test Direct SIWE Provider Interactions

Try calling the SIWE provider directly from the terminal:

```bash
dfx canister call ic_siwe_provider version
```

### Try with Different Browser/Wallet

Sometimes issues can be browser or wallet-specific. Try using a different browser or wallet to isolate the issue.

## If All Else Fails

As a last resort, you can try a complete reset:

```bash
# Stop dfx
dfx stop

# Remove all .dfx data
rm -rf .dfx

# Remove node_modules
rm -rf src/bitobytes_frontend/node_modules

# Install fresh dependencies
cd src/bitobytes_frontend
npm install

# Start fresh dfx instance
dfx start --clean --background

# Deploy everything
dfx deploy
```

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Luke Foster

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: make-scripts-executable.sh
================
#!/bin/bash

# Make all scripts executable
chmod +x reset-siwe.sh
chmod +x deploy-rust-siwe.sh
chmod +x test-siwe-canister.sh
chmod +x update-dependencies.sh

echo "All scripts are now executable"

================
File: README-SIWE.md
================
# Sign in with Ethereum (SIWE) for BitOBytes

This document provides instructions on how to use the Sign in with Ethereum (SIWE) functionality in the BitOBytes application.

## Overview

BitOBytes now supports authentication using Ethereum wallets through the Sign in with Ethereum (SIWE) protocol. This allows users to sign in using their Ethereum wallet (like MetaMask) instead of traditional username/password authentication.

## Prerequisites

- An Ethereum wallet (MetaMask, WalletConnect, etc.)
- Internet Computer SDK (dfx) installed

## Setup

1. Clone the repository and navigate to the project directory:

```bash
git clone https://github.com/yourusername/BitOBytes.git
cd BitOBytes
```

2. Install dependencies:

```bash
cd src/bitobytes_frontend
npm install
```

3. Deploy the Rust-based SIWE provider canister:

```bash
chmod +x deploy-rust-siwe.sh
./deploy-rust-siwe.sh
```
   This script will:
   - Create the SIWE provider canister
   - Set the necessary environment variables
   - Deploy the canister with the appropriate configuration

4. Start the development server:

```bash
# If dfx is not already running
dfx start --background

# Deploy all canisters
dfx deploy

# Start the Next.js development server
cd src/bitobytes_frontend
npm run dev
```

5. Verify the deployment:
   - Check that the canister ID is correctly set in the environment variables
   - The canister ID should match the output from `dfx canister id ic_siwe_provider`

## Usage

1. Navigate to the application in your browser (usually at http://localhost:3000).
2. Click on "Sign In" in the navigation bar.
3. On the sign-in page, follow these steps:
   - Step 1: Connect your Ethereum wallet by clicking the "Connect Wallet" button.
   - Step 2: Sign in with Ethereum by clicking the "Sign In with Ethereum" button.
   - Your wallet will prompt you to sign a message. This signature is used to authenticate you with the Internet Computer.
4. Once signed in, you can access protected routes like the Profile page.

## Test Signing

The sign-in page also includes a "Test Sign" button that allows you to test your wallet's signing capability without going through the full authentication flow. This is useful for debugging or verifying that your wallet is working correctly.

## Implementation Details

The SIWE functionality is implemented using the following components:

- `ic-siwe-js`: A JavaScript library for integrating SIWE with Internet Computer applications.
- `wagmi`: A React hooks library for Ethereum.
- `viem`: A TypeScript interface for Ethereum.
- `ic_siwe_provider`: A Rust-based canister that handles the SIWE authentication on the Internet Computer.

## Troubleshooting

- If you encounter issues with wallet connection, make sure your wallet is unlocked and connected to the correct network (Ethereum Mainnet or Sepolia Testnet).
- If you see errors related to the SIWE provider canister, make sure it's deployed correctly by running `./deploy-rust-siwe.sh`.
- For other issues, check the browser console for error messages.

## Security Considerations

- The SIWE implementation uses delegated identity, which means your Ethereum private key is never exposed to the application.
- The signed message includes a nonce and expiration time to prevent replay attacks.
- The delegation has a limited lifetime (24 hours by default) after which you'll need to sign in again.
- The Rust-based implementation provides proper cryptographic verification of Ethereum signatures.
- The implementation follows the EIP-4361 (SIWE) standard for secure authentication.

================
File: README.md
================
# BitOBytes

BitOBytes is a decentralized TikTok-like platform built on the Internet Computer Protocol (ICP). This project serves as a simple MVP for a video sharing platform where users can upload, view, and interact with short videos in a decentralized manner.

## Features

- Decentralized video storage (planned integration with Arweave/IPFS)
- User authentication via Internet Identity (coming soon)
- Upload videos with titles and descriptions
- Like videos
- View video feed

## Tech Stack

- **Backend**: Internet Computer Canister developed with Motoko
- **Frontend**: Next.js with TypeScript
- **Styling**: TailwindCSS
- **Authentication**: Internet Identity (upcoming)
- **Storage**: Arweave/IPFS (planned)

## Development Setup

### Prerequisites

- Install the DFINITY SDK (dfx)
- Node.js (v14+) and npm

### Getting Started

1. Clone the repository:
   ```
   git clone https://github.com/yourusername/bitobytes.git
   cd bitobytes
   ```

2. Start the local Internet Computer replica:
   ```
   dfx start --clean --background
   ```

3. Deploy the canisters to the local replica:
   ```
   dfx deploy
   ```

4. Install the frontend dependencies:
   ```
   cd src/bitobytes_frontend
   npm install
   ```

5. Generate the canister interface bindings:
   ```
   dfx generate
   ```

6. Start the Next.js development server:
   ```
   npm run dev
   ```

7. Visit `http://localhost:3000` to see the application.

## Testing the Canister

You can interact with the deployed canister directly using the following commands:

### Add a video
```
dfx canister call bitobytes_backend addVideo '("My Test Video", "https://example.com/video.mp4")'
```

### Get all videos
```
dfx canister call bitobytes_backend getVideos
```

### Like a video
```
dfx canister call bitobytes_backend likeVideo '(0)'
```

## Deployment

To deploy to the Internet Computer mainnet:

```
dfx deploy --network ic
```

## Project Structure

```
bitobytes/
├── .dfx/             # Local state and build artifacts (generated)
├── .gitignore        # Git ignore file
├── dfx.json          # DFX configuration
├── src/              # Source code
│   ├── bitobytes_backend/     # Motoko canister code
│   │   └── main.mo            # Main backend code
│   └── bitobytes_frontend/    # Next.js frontend
│       ├── src/               # Frontend source code
│       ├── package.json       # Frontend dependencies
│       └── ...                # Other Next.js config files
└── README.md         # Project documentation
```

## Next Steps

- [ ] Implement Internet Identity authentication
- [ ] Add video upload functionality with Arweave/IPFS
- [ ] Implement video playback
- [ ] Add comments feature
- [ ] Create user profiles
- [ ] Implement search functionality

================
File: reset-siwe.sh
================
#!/bin/bash

# Exit on error
set -e

echo "Resetting SIWE environment and redeploying canister..."

# Stop any running dfx instances
echo "Stopping any running dfx instances..."
dfx stop || true

# Clear .dfx directory for the SIWE provider
echo "Clearing .dfx directory for SIWE provider..."
rm -rf .dfx/local/canisters/ic_siwe_provider

# Clear browser storage data (instruction for user)
echo "IMPORTANT: Please clear your browser's local storage to remove any cached SIWE data."
echo "In Chrome/Edge: DevTools > Application > Storage > Clear site data"
echo "In Firefox: DevTools > Storage > Local Storage > Right click > Delete All"

# Start dfx
echo "Starting dfx..."
dfx start --clean --background

# Deploy the SIWE provider with proper arguments
echo "Deploying SIWE provider canister..."
./deploy-rust-siwe.sh

echo "SIWE provider deployed successfully!"
echo "Next steps:"
echo "1. Clear your browser's local storage"
echo "2. Navigate to the frontend directory: cd src/bitobytes_frontend"
echo "3. Start the development server: npm run dev"
echo "4. Open your browser at http://localhost:3000"

================
File: setup.sh
================
#!/bin/bash

# A simple script to set up the BitOBytes project

echo "Setting up BitOBytes..."

# Create necessary directories
mkdir -p dist

# Check if dfx is installed
if ! command -v dfx &> /dev/null
then
    echo "dfx could not be found. Please install the DFINITY SDK first:"
    echo "sh -ci \"$(curl -fsSL https://sdk.dfinity.org/install.sh)\""
    exit 1
fi

# Check if Node.js is installed
if ! command -v node &> /dev/null
then
    echo "Node.js could not be found. Please install Node.js (v14+) first."
    exit 1
fi

# Start the local replica if not already running
if ! dfx ping &> /dev/null
then
    echo "Starting the local Internet Computer replica..."
    dfx start --clean --background
fi

# Deploy the canisters
echo "Deploying canisters to the local replica..."
dfx deploy

# Install frontend dependencies
echo "Installing frontend dependencies..."
cd src/bitobytes_frontend
npm install

# Generate canister interface bindings
echo "Generating canister interface bindings..."
cd ../..
dfx generate

echo "Setup complete! To start the frontend development server:"
echo "cd src/bitobytes_frontend && npm run dev"
echo "Then visit: http://localhost:3000"

================
File: SIWE-BLS-FIX.md
================
./# SIWE BLS Error Fix Guide

This document explains the changes made to fix the "BLS DER-encoded public key must be 133 bytes long" error in the BitOBytes project.

## Changes Made

1. **Fixed Server-Side Rendering Issues**
   - Modified `rootKeyFetch.ts` to safely handle server-side rendering
   - Updated `_app.tsx` to conditionally apply the fetch patch only in browser environments
   - Added proper checks for browser-specific objects like `window`

2. **Applied Fetch Patch in _app.tsx**
   - Added `patchFetch()` call to ensure the root key is fetched before any requests to the Internet Computer
   - Enabled debug logging for ic-siwe-js to provide more detailed error information
   - Added fallback for canisterId to ensure it's always a string

3. **Updated Canister ID Handling in declarations/index.js**
   - Removed the hardcoded fallback canister ID to prevent mismatches
   - Added error logging when the canister ID is not set

4. **Enhanced Root Key Fetching in AuthProvider.tsx**
   - Added retry mechanism for root key fetching failures
   - Improved error handling and logging

5. **Improved API Routes**
   - Enhanced error handling for management canister redirects
   - Added better logging for debugging
   - Improved error messages for missing canister IDs

6. **Created Verification Script**
   - Added `verify-siwe-setup.sh` to check and fix common issues with the SIWE setup

## How to Fix the BLS Error

If you're still experiencing the "BLS DER-encoded public key must be 133 bytes long" error, follow these steps:

### Step 1: Run the Verification Script

```bash
./verify-siwe-setup.sh
```

This script will:
- Check if dfx is running
- Verify the SIWE canister exists and is accessible
- Ensure environment variables are correctly set
- Check frontend dependencies

### Step 2: Clear Browser Storage

Clear your browser's local storage to remove any cached SIWE data:
- Chrome/Edge: DevTools > Application > Storage > Clear site data
- Firefox: DevTools > Storage > Local Storage > Right click > Delete All

### Step 3: Restart the Development Server

```bash
cd src/bitobytes_frontend
npm run dev
```

### Step 4: If the Error Persists

If the error still persists, try a complete reset:

```bash
./reset-siwe.sh
```

This will:
- Stop any running dfx instances
- Clear the .dfx directory for the SIWE provider
- Start dfx with a clean state
- Deploy the SIWE provider with proper arguments

## Understanding the BLS Error

The "BLS DER-encoded public key must be 133 bytes long" error occurs when:

1. The root key is not properly fetched for local development
2. There's a mismatch between the canister ID used in the code and the actual canister ID
3. The management canister redirect is not working correctly
4. There are cached delegations in the browser that are no longer valid

The changes made address all these potential causes by:
- Ensuring the root key is fetched before any requests
- Verifying the canister ID is consistent across all files
- Improving the management canister redirect logic
- Providing clear instructions for clearing browser storage

## Debugging Tips

1. Check the browser console for errors
2. Look for "Root key fetched successfully" messages
3. Verify the canister ID being used matches the actual canister ID
4. Check the API route logs for any errors in the management canister redirect

## References

- [SIWE Specification (EIP-4361)](https://eips.ethereum.org/EIPS/eip-4361)
- [ic-siwe-js Documentation](https://github.com/kristoferlund/ic-siwe/tree/main/packages/ic-siwe-js)
- [Internet Computer Documentation](https://internetcomputer.org/docs/current/developer-docs/)

================
File: SIWE-IMPLEMENTATION.md
================
# Sign In With Ethereum (SIWE) Implementation Guide

This document provides instructions on how to use the SIWE authentication in the BitOBytes project.

## Overview

The BitOBytes project uses the Sign In With Ethereum (SIWE) standard to authenticate users. This implementation allows users to connect their Ethereum wallet and sign a message to authenticate with the Internet Computer.

## Local Development

### Setup

1. Make sure you have the Internet Computer SDK (dfx) installed:
   ```bash
   sh -ci "$(curl -fsSL https://internetcomputer.org/install.sh)"
   ```

2. Start the local Internet Computer replica:
   ```bash
   dfx start --clean --background
   ```

3. Deploy the SIWE provider for local development:
   ```bash
   ./deploy-siwe.sh
   ```

4. Deploy the backend canister:
   ```bash
   dfx deploy bitobytes_backend
   ```

5. Start the Next.js development server:
   ```bash
   cd src/bitobytes_frontend
   npm run dev
   ```

6. Open your browser and navigate to http://localhost:3000

### Authentication Flow

1. Click the "Connect" button to connect your Ethereum wallet
2. Once connected, click the "Sign Wallet" button to sign the SIWE message
3. After signing, you'll be authenticated and can access protected resources

## Production Deployment

### Setup

1. Update the production domain in the `deploy-siwe.sh` script:
   ```bash
   DOMAIN="your-production-domain.icp0.io"
   URI="https://your-production-domain.icp0.io"
   ```

2. Deploy the SIWE provider for production:
   ```bash
   ./deploy-siwe.sh production
   ```

3. Deploy the backend canister:
   ```bash
   dfx deploy --network ic bitobytes_backend
   ```

4. Build and deploy the frontend:
   ```bash
   cd src/bitobytes_frontend
   npm run build
   dfx deploy --network ic bitobytes_frontend
   ```

## Environment Variables

The following environment variables are used for the SIWE implementation:

- `NEXT_PUBLIC_SIWE_CANISTER_ID`: The canister ID of the SIWE provider
- `NEXT_PUBLIC_IC_HOST`: The host of the Internet Computer replica (http://localhost:4943 for local development, https://ic0.app for production)

These variables are automatically set by the `deploy-siwe.sh` script.

## Troubleshooting

### Common Issues

1. **"BLS DER-encoded public key must be 133 bytes long" error**:
   - This error occurs when the root key is not properly fetched or when the SIWE provider is not properly configured.
   - Make sure you're running the latest version of dfx.
   - Try restarting the local replica with `dfx start --clean --background`.
   - Redeploy the SIWE provider with `./deploy-siwe.sh`.

2. **"Failed to fetch root key" error**:
   - This error occurs when the API routes can't connect to the Internet Computer replica.
   - Make sure the replica is running with `dfx ping`.
   - Check that the `NEXT_PUBLIC_IC_HOST` environment variable is correctly set.

3. **Authentication fails after signing the message**:
   - Check the browser console for errors.
   - Make sure the SIWE provider is correctly configured with the right domain and URI.
   - Verify that the management canister redirection is working correctly in the API routes.

## References

- [SIWE Specification (EIP-4361)](https://eips.ethereum.org/EIPS/eip-4361)
- [ic-siwe-js Documentation](https://github.com/kristoferlund/ic-siwe/tree/main/packages/ic-siwe-js)
- [Internet Computer Documentation](https://internetcomputer.org/docs/current/developer-docs/)

================
File: SIWE-MIGRATION.md
================
# SIWE Migration: Motoko to Rust Implementation

This document explains the migration from the custom Motoko-based SIWE provider to the official Rust-based implementation.

## Changes Made

1. **Updated dfx.json**
   - Replaced the Motoko-based `ic_siwe_provider` with the pre-built Rust canister
   - The canister now uses the official WASM module and candid interface

2. **Created New Deployment Script**
   - Added `deploy-rust-siwe.sh` for deploying the Rust-based SIWE provider
   - Configured with appropriate settings for BitOBytes

3. **Updated Documentation**
   - Updated README-SIWE.md to reflect the new implementation
   - Added information about the security benefits

## Benefits of the Rust Implementation

### 1. Security Improvements

- **Proper Cryptographic Verification**: Unlike the Motoko placeholder that accepted any signature, the Rust implementation properly verifies Ethereum signatures.
- **Nonce-based Security**: Prevents replay attacks with proper nonce handling.
- **Timebound Sessions**: Configurable expiration for both sign-in messages and sessions.
- **Delegation Targets**: Restricts which canisters can use the delegated identity.

### 2. Compatibility

- **Standard Compliance**: Follows the EIP-4361 (SIWE) standard for secure authentication.
- **Frontend Compatibility**: Works seamlessly with the existing `ic-siwe-js` library.
- **No Frontend Changes Required**: Your existing React components should work without modification.

### 3. Maintainability

- **Production-Ready**: The Rust implementation is production-ready with comprehensive error handling.
- **Well-Documented**: Extensive documentation and examples available.
- **Actively Maintained**: Regular updates and security patches.

## How It Works

The Rust-based SIWE provider follows this authentication flow:

1. **Prepare Login**: Generates a SIWE message with a nonce for the user to sign.
2. **Login**: Verifies the signature and creates a delegation for the session.
3. **Get Delegation**: Provides a signed delegation that can be used for authentication.

## Configuration Options

The Rust-based SIWE provider is configured with these parameters:

- `domain`: The domain from where the frontend is served
- `uri`: The full URI of the frontend
- `salt`: Used for generating unique user principals
- `chain_id`: Ethereum chain ID (default: 1 for mainnet)
- `scheme`: Protocol scheme (http/https)
- `statement`: Message shown to users when signing
- `sign_in_expires_in`: TTL for sign-in messages (nanoseconds)
- `session_expires_in`: TTL for sessions (nanoseconds)
- `targets`: List of canisters allowed for delegation

## Testing the Migration

To test the migration:

1. Deploy the Rust-based SIWE provider:
   ```bash
   ./deploy-rust-siwe.sh
   ```

2. Start the development server:
   ```bash
   dfx start --background
   dfx deploy
   cd src/bitobytes_frontend
   npm run dev
   ```

3. Test the authentication flow by signing in with an Ethereum wallet.

## Troubleshooting

### Canister ID Not Found Error

If you encounter a "canister_id_not_found" error, follow these steps:

1. Make sure you've deployed the Rust-based SIWE provider:
   ```bash
   ./deploy-rust-siwe.sh
   ```

2. Verify that the environment variables are set correctly:
   - Check that `src/bitobytes_frontend/.env` contains the correct canister ID
   - The canister ID should match the output from `dfx canister id ic_siwe_provider`

3. Restart your Next.js development server:
   ```bash
   cd src/bitobytes_frontend
   npm run dev
   ```

4. If the issue persists, try clearing your browser cache or using an incognito window.

### Other Common Issues

- If you encounter issues with the deployment, check the dfx.json configuration.
- If authentication fails after successful deployment, check the browser console for specific error messages.
- For wallet connection issues, make sure your wallet is unlocked and connected to a supported network.

================
File: SIWE-TROUBLESHOOTING.md
================
# SIWE Troubleshooting Guide

This document provides solutions for common issues when implementing Sign-In With Ethereum (SIWE) in your Internet Computer application.

## Common Errors

### "BLS DER-encoded public key must be 133 bytes long"

This error occurs due to incompatibility between the Internet Computer identity libraries and the BLS keys used for delegation. 

**Solution:**

1. Update to the latest `ic-siwe-js` library version:
   ```bash
   npm install ic-siwe-js@latest @dfinity/agent@latest @dfinity/identity@latest
   ```

2. Clear browser storage:
   - Chrome/Edge: DevTools > Application > Storage > Clear site data
   - Firefox: DevTools > Storage > Local Storage > Right click > Delete All

3. Redeployment steps:
   ```bash
   # Stop any running dfx instances
   dfx stop
   
   # Start with a clean state
   dfx start --clean
   
   # Re-deploy the SIWE provider canister
   ./deploy-rust-siwe.sh
   ```

### API Request Errors (400 Bad Request)

If you see errors like `POST http://localhost:3000/api/v2/canister/...` or `/api/v3/canister/...` with 400 Bad Request responses:

**Solution:**

1. Ensure your Next.js rewrites are correctly configured in `next.config.js`
2. Add explicit proxy routes for the specific API endpoints
3. Check that the environment variables are correctly set
4. Verify that the IC replica is running (`dfx ping` should succeed)

### Connection Issues with IC Replica

**Solution:**

1. Ensure the IC replica is running: `dfx ping`
2. Check that `NEXT_PUBLIC_IC_HOST` is set to `http://localhost:4943`
3. Verify the agent is configured with `verifyQuerySignatures: false` for local development

## General Troubleshooting Steps

1. **Reset Environment**:
   ```bash
   ./reset-siwe.sh
   ```

2. **Check Canister Status**:
   ```bash
   dfx canister status ic_siwe_provider
   ```

3. **Test Direct Canister Call**:
   ```bash
   dfx canister call ic_siwe_provider version
   ```

4. **Debug Mode**:
   Enable more verbose logging by setting localStorage:
   ```javascript
   localStorage.setItem('debug', 'ic-siwe-js:*');
   ```

5. **Version Compatibility**:
   Ensure that the versions of `ic-siwe-js` npm package and the `ic_siwe_provider` canister WASM module are compatible.

## Advanced Configuration

For advanced users, you can configure the SIWE provider with custom parameters:

```bash
dfx deploy ic_siwe_provider --argument '(
    record {
        domain = "your-domain.icp";
        uri = "https://your-domain.icp";
        salt = "unique-salt-value";
        chain_id = opt 1;
        scheme = opt "https";
        statement = opt "Custom sign-in message";
        sign_in_expires_in = opt 3_600_000_000_000;
        session_expires_in = opt 86_400_000_000_000;
    }
)'
```

## Still Having Issues?

If you continue to experience problems after trying these solutions:

1. Check the [ic-siwe GitHub repository](https://github.com/kristoferlund/ic-siwe) for recent issues
2. Verify your Ethereum wallet is properly connected and on a supported network
3. Try with a different browser or wallet to isolate the issue

================
File: test-siwe-canister.sh
================
#!/bin/bash

# Get the canister ID from environment variables or from the .env file
CANISTER_ID=$(grep NEXT_PUBLIC_SIWE_CANISTER_ID src/bitobytes_frontend/.env | cut -d '=' -f2)

echo "Testing SIWE canister with ID: $CANISTER_ID"

# Try to call a simple method on the canister
echo "Checking canister status..."
dfx canister status $CANISTER_ID

echo "Trying to call version method..."
dfx canister call $CANISTER_ID version

echo "Testing completed. If you see a version number above, the canister is accessible."

================
File: update-dependencies.sh
================
#!/bin/bash

# Navigate to frontend directory
cd src/bitobytes_frontend

# Update ic-siwe-js to the latest version
npm install ic-siwe-js@latest

# Update related IC libraries to ensure compatibility
npm install @dfinity/agent@latest @dfinity/identity@latest @dfinity/candid@latest

# Clean npm cache
npm cache clean --force

# Reinstall all dependencies to ensure proper resolution
npm install

echo "Dependencies updated successfully!"

================
File: verify-siwe-setup.sh
================
#!/bin/bash

# Exit on error
set -e

echo "===== SIWE Setup Verification Tool ====="
echo "This script will check your SIWE setup and help fix common issues."
echo

# Check if dfx is installed
if ! command -v dfx &> /dev/null; then
    echo "❌ dfx is not installed. Please install the Internet Computer SDK."
    exit 1
fi

# Check if dfx is running
if ! dfx ping &> /dev/null; then
    echo "❌ dfx is not running. Starting local replica..."
    dfx start --background
    sleep 5
else
    echo "✅ dfx is running"
fi

# Check if the SIWE canister exists
if ! dfx canister id ic_siwe_provider &> /dev/null; then
    echo "❌ SIWE provider canister does not exist. Deploying..."
    ./deploy-rust-siwe.sh
else
    echo "✅ SIWE provider canister exists"
    CANISTER_ID=$(dfx canister id ic_siwe_provider)
    echo "   Canister ID: $CANISTER_ID"
fi

# Check if the SIWE canister is accessible
echo "Testing SIWE canister..."
if ! dfx canister call ic_siwe_provider version &> /dev/null; then
    echo "❌ SIWE provider canister is not accessible. Redeploying..."
    ./deploy-rust-siwe.sh
else
    echo "✅ SIWE provider canister is accessible"
    VERSION=$(dfx canister call ic_siwe_provider version)
    echo "   Version: $VERSION"
fi

# Check environment variables
echo "Checking environment variables..."
CANISTER_ID=$(dfx canister id ic_siwe_provider)

# Check .env.local
if [ -f "src/bitobytes_frontend/.env.local" ]; then
    ENV_CANISTER_ID=$(grep NEXT_PUBLIC_SIWE_CANISTER_ID src/bitobytes_frontend/.env.local | cut -d '=' -f2)
    if [ "$ENV_CANISTER_ID" != "$CANISTER_ID" ]; then
        echo "❌ NEXT_PUBLIC_SIWE_CANISTER_ID in .env.local does not match the actual canister ID"
        echo "   Updating .env.local..."
        sed -i '' "s/NEXT_PUBLIC_SIWE_CANISTER_ID=.*/NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID/" src/bitobytes_frontend/.env.local
    else
        echo "✅ NEXT_PUBLIC_SIWE_CANISTER_ID in .env.local is correct"
    fi
    
    if ! grep -q "NEXT_PUBLIC_IC_HOST" src/bitobytes_frontend/.env.local; then
        echo "❌ NEXT_PUBLIC_IC_HOST is not set in .env.local"
        echo "   Adding NEXT_PUBLIC_IC_HOST to .env.local..."
        echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env.local
    else
        echo "✅ NEXT_PUBLIC_IC_HOST is set in .env.local"
    fi
else
    echo "❌ .env.local does not exist. Creating..."
    echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env.local
    echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env.local
fi

# Check .env
if [ -f "src/bitobytes_frontend/.env" ]; then
    ENV_CANISTER_ID=$(grep NEXT_PUBLIC_SIWE_CANISTER_ID src/bitobytes_frontend/.env | cut -d '=' -f2)
    if [ "$ENV_CANISTER_ID" != "$CANISTER_ID" ]; then
        echo "❌ NEXT_PUBLIC_SIWE_CANISTER_ID in .env does not match the actual canister ID"
        echo "   Updating .env..."
        sed -i '' "s/NEXT_PUBLIC_SIWE_CANISTER_ID=.*/NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID/" src/bitobytes_frontend/.env
    else
        echo "✅ NEXT_PUBLIC_SIWE_CANISTER_ID in .env is correct"
    fi
    
    if ! grep -q "NEXT_PUBLIC_IC_HOST" src/bitobytes_frontend/.env; then
        echo "❌ NEXT_PUBLIC_IC_HOST is not set in .env"
        echo "   Adding NEXT_PUBLIC_IC_HOST to .env..."
        echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env
    else
        echo "✅ NEXT_PUBLIC_IC_HOST is set in .env"
    fi
else
    echo "❌ .env does not exist. Creating..."
    echo "NEXT_PUBLIC_SIWE_CANISTER_ID=$CANISTER_ID" > src/bitobytes_frontend/.env
    echo "NEXT_PUBLIC_IC_HOST=http://localhost:4943" >> src/bitobytes_frontend/.env
fi

# Check if the frontend dependencies are installed
echo "Checking frontend dependencies..."
if [ ! -d "src/bitobytes_frontend/node_modules" ]; then
    echo "❌ Frontend dependencies are not installed. Installing..."
    cd src/bitobytes_frontend
    npm install
    cd ../..
else
    echo "✅ Frontend dependencies are installed"
fi

# Check for server-side rendering issues
echo "Checking for server-side rendering issues..."
if grep -q "window is not defined" src/bitobytes_frontend/dist/server/pages/_app.js 2>/dev/null; then
    echo "❌ Server-side rendering issue detected: 'window is not defined'"
    echo "   This is likely caused by accessing browser-specific objects in a server context."
    echo "   Please ensure all browser-specific code is wrapped in 'if (typeof window !== 'undefined')' checks."
else
    echo "✅ No obvious server-side rendering issues detected"
fi

echo
echo "===== Verification Complete ====="
echo
echo "If you're still experiencing the 'BLS DER-encoded public key must be 133 bytes long' error:"
echo "1. Clear your browser's local storage:"
echo "   - Chrome/Edge: DevTools > Application > Storage > Clear site data"
echo "   - Firefox: DevTools > Storage > Local Storage > Right click > Delete All"
echo "2. Restart the development server:"
echo "   cd src/bitobytes_frontend && npm run dev"
echo "3. Try logging in again"
echo
echo "If you see 'window is not defined' errors:"
echo "1. Make sure all browser-specific code is wrapped in checks:"
echo "   if (typeof window !== 'undefined') { /* browser-only code */ }"
echo "2. Ensure fetch patching happens only in the browser context"
echo
echo "If the error persists, try a complete reset:"
echo "./reset-siwe.sh"
echo



================================================================
End of Codebase
================================================================
